/*
 * Copyright (c) 2019
 * California Department of Water Resources
 * All Rights Reserved.  DWR PROPRIETARY/CONFIDENTIAL.
 * Source may not be released without written approval from DWR
 */

package calsim.app;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.LineNumberReader;
import java.io.PrintWriter;
import java.util.Date;
import java.util.StringTokenizer;
import java.util.Vector;
import javax.swing.table.AbstractTableModel;

/**
 * This class reads in a lookup table
 *
 * @author Nicky Sandhu
 * @version $Id: LookupTableData.java,v 1.1.2.4 2001/07/12 01:58:27 amunevar Exp $
 */
public class LookupTableData extends AbstractTableModel implements InputTableData
{
	private String _file;
	private String[] _comments;
	private String _tableName;
	private String[] _columns;
	private Vector _rows;
	private boolean _needsSaving;

	//
	public LookupTableData()
	{
		_file = "";
		_comments = new String[]{""};
		_tableName = "";
		_columns = new String[]{""};
		_rows = new Vector();
		_needsSaving = false;
	}

	//
	public LookupTableData(String filename)
	{
		load(filename);
	}

	public void save() throws IOException
	{
		save(_file);
	}

	public void save(String filename)
	{
		PrintWriter writer = null;
		try
		{
			if(!filename.equals(_file))
			{
				System.err.println("Ignoring filename " + filename);
				System.err.println("Using filename " + _file + " instead");
			}
			filename = _file;
			writer = new PrintWriter(new FileWriter(filename));
			writer.println("!Auto Generated by LookupTable on " + new Date());
			for(int i = 0; i < _comments.length; i++)
			{
				if(!_comments[i].equals(""))
				{
					writer.println("!" + _comments[i]);
				}
			}
			writer.println(_tableName);
			for(int i = 0; i < _columns.length - 1; i++)
			{
				writer.print(_columns[i]);
				writer.print("\t");
			}
			writer.println(_columns[_columns.length - 1]);
			//
			int sz = _rows.size();
			for(int j = 0; j < sz; j++)
			{
				String[] data = ((DataTuple) _rows.elementAt(j)).getData();
				for(int i = 0; i < data.length - 1; i++)
				{
					writer.print(data[i]);
					writer.print("\t");
				}
				writer.println(data[data.length - 1]);
			}
			_needsSaving = false;
		}
		catch(IOException ioe)
		{
			throw new RuntimeException("IOError saving file: " + _file + " Error Msg: " + ioe.getMessage());
		}
		finally
		{
			if(writer != null)
			{
				writer.close();
			}
		}
	}

	public void load(String filename)
	{
		LineNumberReader reader = null;
		try
		{
			_file = filename;
			reader = new LineNumberReader(new FileReader(_file));
			_rows = new Vector();
			Vector comments = new Vector();
			String line;
			while((line = reader.readLine()) != null)
			{
				line = line.trim();
				if(!line.startsWith("!"))
				{
					// if first line get table name
					if(_tableName == null)
					{
						_tableName = line.trim();
						continue;
					}
					// if second line get column names and number
					if(_columns == null)
					{
						StringTokenizer st = new StringTokenizer(line.trim());
						if(st.countTokens() == 0)
						{
							throw new RuntimeException(
									"No columns defined or column definition not immediately after table name");
						}
						_columns = new String[st.countTokens()];
						for(int i = 0; i < _columns.length; i++)
						{
							_columns[i] = st.nextToken().trim();
						}
						continue;
					}
					// if third line or greater get data
					StringTokenizer st = new StringTokenizer(line.trim());
					int count = st.countTokens();
					if(count > _columns.length)
					{
						System.err.println(
								"Incompatible number of data: Ignoring extras in " + line + " of table " + _file);
						continue;
					}
					else if(count < _columns.length)
					{
						System.err.println(
								"Insufficient data w.r.t. to columns defined in line " + line + " of table " + _file);
						continue;
					}
					else
					{
						DataTuple data = new DataTuple(_columns.length);
						for(int i = 0; i < _columns.length; i++)
						{
							data.setValueAt(i, st.nextToken());
						}
						_rows.addElement(data);
					}
				}
				else
				{
					if(line.indexOf("uto generated") >= 0)
					{
						continue;
					}
					comments.addElement(line.substring(1));
					continue;
				}
			}
			if(comments.size() > 0)
			{
				_comments = new String[comments.size()];
				comments.copyInto(_comments);
			}
			else
			{
				_comments = new String[]{""};
			}
		}
		catch(FileNotFoundException e)
		{
			throw new RuntimeException("File " + _file + " not found ");
		}
		catch(IOException e)
		{
			throw new RuntimeException("Error loading file: " + _file + " Error Msg: " + e.getMessage());
		}
		finally
		{
			try
			{
				if(reader != null)
				{
					reader.close();
				}
			}
			catch(Exception e)
			{
				System.err.println("Could not close input stream to " + _file);
			}
		}
	}
	//

	/**
	 * the name of this table
	 */
	public String getTableName()
	{
		return _tableName;
	}

	/**
	 * the header array for column names
	 */
	public String[] getHeaders()
	{
		return _columns;
	}

	/**
	 * the number of rows of data
	 */
	public int getNumberOfRows()
	{
		return _rows.size();
	}

	/**
	 * the row data @ the ith row, the length of which must match the # of cols
	 */
	public String[] getRowData(int i)
	{
		//    String [] dstr = new String[_columns.length];
		DataTuple data = (DataTuple) _rows.elementAt(i);
		return data.getData();
	}

	/**
	 * adds a row to this table
	 */
	public void addRow(String[] rowData)
	{
		if(rowData.length != _columns.length)
		{
			throw new RuntimeException("Incorrect # of data for row");
		}
		DataTuple data = new DataTuple(_columns.length);
		for(int k = 0; k < _columns.length; k++)
		{
			data.setValueAt(k, rowData[k]);
		}
		_rows.addElement(data);
		_needsSaving = true;
	}

	/**
	 * inserts a row in this table
	 */
	public void insertRow(int i, String[] rowData)
	{
		if(rowData.length != _columns.length)
		{
			throw new RuntimeException("Incorrect # of data for row");
		}
		DataTuple data = new DataTuple(_columns.length);
		for(int k = 0; k < _columns.length; k++)
		{
			data.setValueAt(k, rowData[k]);
		}
		_rows.insertElementAt(data, i);
		_needsSaving = true;
	}

	/**
	 * removes a row from this table
	 */
	public void removeRow(int i)
	{
		_rows.removeElementAt(i);
		_needsSaving = true;
	}

	/**
	 * gets comment string
	 */
	public String getComment()
	{
		String line = "";
		for(int k = 0; k < _comments.length; k++)
		{
			line = line + _comments[k] + "\n";
		}
		return line;
	}

	/**
	 * sets comment string
	 */
	public void setComment(String comment)
	{
		StringTokenizer st = new StringTokenizer(comment, "\n");
		//System.out.println("Comment: " + comment);
		//System.out.println("No. of lines = " + st.countTokens());
		if(st.countTokens() == 0)
		{
			_comments = new String[]{""};
		}
		else
		{
			_comments = new String[st.countTokens()];
			for(int k = 0; k < _comments.length; k++)
			{
				_comments[k] = st.nextToken();
			}
		}
		_needsSaving = true;
	}

	/**
	 * the current input file or last file to which saved to or loaded from
	 */
	public String getInputFile()
	{
		return _file;
	}

	/**
	 * sort on given column
	 */
	public void sort(int column)
	{
		// do nothing
	}

	/**
	 * reverse the elements
	 */
	public void reverse()
	{
		// do nothing
	}
	/*
	 * All table model specific stuff is below this line
	 */

	/**
	 * Number of data references used in DTS calculations
	 */
	public int getRowCount()
	{
		return getNumberOfRows();
	}

	/**
	 * Number of columns in the table
	 */
	public int getColumnCount()
	{
		return getHeaders().length;
	}

	/**
	 * Returns the name of the column at <i>columnIndex</i>.
	 *
	 * @return the name of the column
	 * @param    columnIndex    the index of column
	 */
	public String getColumnName(int columnIndex)
	{
		return getHeaders()[columnIndex];
	}

	/**
	 * Returns true if the cell at <I>rowIndex</I> and <I>columnIndex</I>
	 * is editable.  Otherwise, setValueAt() on the cell will not change
	 * the value of that cell.
	 *
	 * @param    rowIndex    the row whose value is to be looked up
	 * @param    columnIndex    the column whose value is to be looked up
	 * @return true if the cell is editable.
	 * @see #setValueAt
	 */
	public boolean isCellEditable(int rowIndex, int columnIndex)
	{
		return true;
	}

	/**
	 * Returns an attribute value for the cell at <I>columnIndex</I>
	 * and <I>rowIndex</I>.
	 *
	 * @param    rowIndex    the row whose value is to be looked up
	 * @param    columnIndex the column whose value is to be looked up
	 * @return the value Object at the specified cell
	 */
	public Object getValueAt(int rowIndex, int columnIndex)
	{
		return getRowData(rowIndex)[columnIndex];
	}

	/**
	 * Sets an attribute value for the record in the cell at
	 *
	 * @param    aValue         the new value
	 * @param    rowIndex     the row whose value is to be changed
	 * @param    columnIndex the column whose value is to be changed
	 * @see #getValueAt
	 * @see #isCellEditable
	 */
	public void setValueAt(Object aValue, int rowIndex, int columnIndex)
	{
		getRowData(rowIndex)[columnIndex] = aValue.toString();
		_needsSaving = true;
	}

	/**
	 * true if data has been modified since last save
	 */
	public boolean needsSaving()
	{
		return _needsSaving;
	}

	/**
	 *
	 */
	public class DataTuple
	{
		private String[] _data;

		public DataTuple(int count)
		{
			_data = new String[count];
		}

		public int getNumberOfValues()
		{
			return _data.length;
		}

		public String getValueAt(int i)
		{
			return _data[i];
		}

		public void setValueAt(int i, String str)
		{
			_data[i] = str;
		}

		public String[] getData()
		{
			return _data;
		}
	}
}
