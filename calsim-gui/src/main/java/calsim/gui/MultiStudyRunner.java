/*
 * Copyright (c) 2019
 * California Department of Water Resources
 * All Rights Reserved.  DWR PROPRIETARY/CONFIDENTIAL.
 * Source may not be released without written approval from DWR
 */

package calsim.gui;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import javax.swing.*;

import calsim.app.AppUtils;
import calsim.app.CSVParser;
import calsim.app.Study;
import calsim.wreslcoder.WreslIncScanner;
import calsim.wreslcoder.WreslMaker;
import vista.db.dss.DSSUtil;
import vista.set.DataReference;
import vista.set.Group;
import vista.time.Time;
import vista.time.TimeFactory;
import vista.time.TimeWindow;

//import java.awt.*;
//import java.awt.event.*;
//import javax.swing.table.*;

/**
 * The study tab.  It Provides all the properties in every panel
 * in the study tab and contains the run and check methods
 *
 * @author Armin Munevar
 * @version ID: StudyTab.java, v 0.7 beta, 07/29/99
 */

public class MultiStudyRunner
{
	public static boolean DEBUG = false;
	//CB  private static String calsimLibDir = System.getProperty("calsim.home") + File.separator + "lib";
	//CB  private static String calsimLibDir = System.getenv("calsim.home") + File.separator + "lib"; //CB replaced cause Eclipse can set environment variables
	private static String calsimLibDir;  //CB
	final String _b2String = "B2";
	final String _ewaString = "EWA";
	Vector _b2ToFile = new Vector(1, 1);
	Vector _b2NewPath = new Vector(1, 1);
	Vector _b2Ref = new Vector(1, 1);
	Vector _ewaToFile = new Vector(1, 1);
	Vector _ewaNewPath = new Vector(1, 1);
	Vector _ewaRef = new Vector(1, 1);
	TimeWindow _tw;
	private PrintWriter _output;
	private Study _study;
	private WreslMaker _wm;
	private boolean _hideWarnings = true; //CB added
	private boolean _hideProgressDetails = true; //CB added
	//  private boolean _hasUserMappedOpenProblem = true; //CB added
	private int _parseFileDelay = 0;  //CB added

	/**
	 * Constructors
	 */
	public MultiStudyRunner(boolean hideWarnings, boolean hideProgressDetails)
	{
		_hideWarnings = hideWarnings;
		_hideProgressDetails = hideProgressDetails;
		setLibraryDirectory(); // CB added
	}

	/**
	 * Sets a status message in a parallel thread
	 */
	public static void setStatusInThread(String msg)
	{
		//    GuiUtils.setStatus(msg);
	}

	/**
	 * CB added because batch file sets calsim.home Property, but in Eclipse it is in environment variables.
	 */
	private void setLibraryDirectory()
	{
		if(System.getenv("calsim.home") != null)
		{
			//			System.out.println("getenv did NOT return null");
			calsimLibDir = System.getenv("calsim.home") + File.separator + "lib"; //Eclipse project settings sets
			//			System.out.println("calsimLibDir = " + calsimLibDir);
		}
		else
		{
			//			System.out.println("getenv DID return null");
			calsimLibDir = System.getProperty("calsim.home") + File.separator + "lib"; //batch file sets
			//			System.out.println("calsimLibDir = " + calsimLibDir);
		}
	}

	/**
	 * Gets the current study
	 */
	public Study getStudy()
	{
		return _study;
	}

	/**
	 * Set the current study
	 */
	public void setStudy(Study study)
	{
		_study = study;
	}

	/**
	 * Write study.sty file to current run directory for Fortran
	 */
	public void saveStudyFile()
	{
		Object obj;
		Vector v = _study.getAllProperties();
		try
		{
			File wreslFile = new File(_study.getWreslFile());
			String studyDir = wreslFile.getParent();
			PrintWriter studyPrintWriter = new PrintWriter(
					new BufferedWriter(new FileWriter(studyDir + File.separator + "study.sty")));
			studyPrintWriter.println("Study File: Generated by CALSIM. Do Not Edit!");
			for(Enumeration e = v.elements(); e.hasMoreElements(); )
			{
				obj = e.nextElement();
				if(obj != null)
				{
					studyPrintWriter.println(obj.toString().toUpperCase());
				}
				else
				{
					studyPrintWriter.println("");
				}
			}
			studyPrintWriter.close();
		}
		catch(IOException e)
		{
			System.out.println(e.getMessage());
		}
	}

	/**
	 * Write study.sty file to current run directory for Fortran
	 */
	public void saveStudyFile(Study sty)
	{
		Object obj;
		Vector v = sty.getAllProperties();
		try
		{
			File wreslFile = new File(sty.getWreslFile());
			String studyDir = wreslFile.getParent();
			PrintWriter studyPrintWriter = new PrintWriter(
					new BufferedWriter(new FileWriter(studyDir + File.separator + "study.sty")));
			studyPrintWriter.println("Study File: Generated by CALSIM. Do Not Edit!");
			for(Enumeration e = v.elements(); e.hasMoreElements(); )
			{
				obj = e.nextElement();
				if(obj != null)
				{
					studyPrintWriter.println(obj.toString().toUpperCase());
				}
				else
				{
					studyPrintWriter.println("");
				}
			}
			studyPrintWriter.close();
		}
		catch(IOException e)
		{
			System.out.println(e.getMessage());
		}
	}

	/**
	 * Check the required study properties
	 */
	private boolean containsRequiredProperties()
	{
		return _study.getName().length() != 0 &&
				_study.getHydrologyVersion().length() != 0 &&
				_study.getWreslFile().length() != 0 &&
				_study.getSvFile().length() != 0 &&
				_study.getDvFile().length() != 0;
	}

	/**
	 * Scans Wresl file dates and compares to executable
	 */
	public boolean newerFiles(String wreslFileName)
	{
		String msg = "";
		_output = new PrintWriter(System.out);
		File wreslFile = new File(wreslFileName);
		String studyDir = wreslFile.getParent().toUpperCase();
		String common = _study.getCommonPath();
		try
		{
			_wm = new WreslMaker(studyDir, common, wreslFileName, _output, false, _hideWarnings,
					_hideProgressDetails, _parseFileDelay);
			WreslIncScanner scanner = new WreslIncScanner(wreslFileName);
			if(scanner.getNewerList(WreslMaker.makeExeFile(wreslFileName)).size() > 0)
			{
				return true;
			}
		}
		catch(FileNotFoundException e)
		{
			msg = "File Not Found! " + e.getMessage();
			JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
		}
		catch(calsim.wreslcoder.wresl.TokenMgrError e)
		{
			_output.println(e.getMessage());
			msg = "Wresl Token Error! ";
			JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
		}
		finally
		{
			System.gc();
		}
		return false;
	}

	/**
	 * Parses the Wresl files
	 */
	public int parseFiles()
	{
		String msg = "";
		try
		{
			msg = "Parsing ... ";
			setStatusInThread(msg);
			if(_study.getWreslFile().indexOf("-") != -1)
			{
				msg = "Illegal Directory Name! No '-' characters are allowed: " + _study.getWreslFile();
				JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
				return 1;
			}
			_wm.parse();
			Integer numberCycles = _study.getNumberSequences();
			Integer numberWreslCycles = new Integer(_wm.getNumberOfWreslCycles());
			if(numberCycles.intValue() != numberWreslCycles.intValue())
			{
				msg = "Number of sequences must be same as specified in Wresl!";
				JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
				return 1;
			}
		}
		catch(calsim.wreslcoder.wresl.TokenMgrError e)
		{
			_output.println(e.getMessage());
			msg = "Wresl Token Error! ";
			JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
		}
		catch(FileNotFoundException e)
		{
			msg = "File Not Found! " + e.getMessage();
			JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
		}
		catch(calsim.wreslcoder.wresl.ParseException e)
		{
			_output.println(e.getMessage());
			msg = "Wresl Parse Error! ";
			JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
		}
		finally
		{
			System.gc();
		}
		return 0;
	}

	/**
	 * Compiles the F90 files
	 */
	public int compile()
	{
		String msg = "Compiling ... ";
		setStatusInThread(msg);
		Integer numberCycles = _study.getNumberSequences();
		for(int i = 0; i <= numberCycles.intValue(); i++)
		{
			if(!_wm.compile(calsimLibDir, java.lang.String.valueOf(i)))
			{
				msg = "Compilation Error!";
				JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
				_output.flush();
				return 1;
			}
		}
		if(!_wm.compileGlobal(calsimLibDir))
		{
			msg = "Compilation Error!";
			JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
			return 1;
		}
		return 0;
	}

	/**
	 * Links the F90 object code
	 */
	public int link()
	{
		String msg = "Linking ... ";
		setStatusInThread(msg);
		if(!_wm.link(calsimLibDir))
		{
			msg = "Link Error!";
			JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
			return 1;
		}
		return 0;
	}

	/**
	 * Runs the F90 executable program containing the study
	 */
	public int execute()
	{
		String msg = "Executing ... ";
		setStatusInThread(msg);
		if(_wm.runModel() > 0)
		{
			msg = "Execution Error!";
			JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
			return 1;
		}
		return 0;
	}

	/**
	 * Parses, compiles, links, and runs the executable
	 */
	public int runall()
	{
		String msg = "";
		int stat = -99;
		saveStudyFile();
		if(containsRequiredProperties() == false)
		{
			msg = "Name, Hydrology Version, Wresl File, and DSS Files are Required!";
			JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
			return stat;
		}
		if(newerFiles(_study.getWreslFile()))
		{
			if((stat = parseFiles()) != 0)
			{
				return stat;
			}
			if((stat = compile()) != 0)
			{
				return stat;
			}
			if((stat = link()) != 0)
			{
				return stat;
			}
		}
		if((stat = execute()) != 0)
		{
			return stat;
		}
		return stat;
	}

	/**
	 * Runs the current study
	 */
	public void runStudy()
	{
		runall();
		_output.close();
	}

	/**
	 * Checks the current study
	 */
	public void checkStudy()
	{
		String msg = "";
		if(newerFiles(_study.getWreslFile()))
		{
			msg = "Parsing ... ";
			setStatusInThread(msg);
			parseFiles();
			msg = "Parsing Complete!";
			setStatusInThread(msg);
			JOptionPane.showMessageDialog(null, msg, "Calsim Info", JOptionPane.INFORMATION_MESSAGE);
		}
		else
		{
			msg = "No Changed Files!";
			JOptionPane.showMessageDialog(null, msg, "Calsim Info", JOptionPane.INFORMATION_MESSAGE);
		}
		_output.close();
	}

	/**
	 * Creates vectors in the first year of the run that hold the name of the files that recieve data
	 * What the new dss pathname is and the datarefences s
	 */
	public void readTransferFile(String file, String type)
	{
		Vector data = new Vector();

		CSVParser parser = new CSVParser(file);
		// read data till empty line
		while(true)
		{
			String[] fields = parser.nextLine();
			if(fields == null)
			{
				break;
			}
			data.addElement(fields);
		}
		parser.close();
		String fromFile = " ";
		String toFile = " ";
		Group g = new Group();
		System.out.println("Reading Transfer File.");
		for(Enumeration e = data.elements(); e.hasMoreElements(); )
		{
			String[] s = (String[]) e.nextElement();
			if(s[0].indexOf("*") == 0)
			{
				fromFile = s[1];
				toFile = s[2];
				g = AppUtils.openDSSFile(fromFile);
			}
			else
			{
				Group gmod = (Group) g.clone();
				gmod.filterBy(s[0]);
				DataReference ref = gmod.getDataReference(0);
				if(type.equalsIgnoreCase(_b2String))
				{
					_b2ToFile.addElement(toFile);
					_b2NewPath.addElement(s[1]);
					_b2Ref.addElement(ref);
				}
				else if(type.equalsIgnoreCase(_ewaString))
				{
					_ewaToFile.addElement(toFile);
					_ewaNewPath.addElement(s[1]);
					_ewaRef.addElement(ref);
				}
			}
		}
		g = null;
	}

	/**
	 * Transfers dss data from one file to another with pathname mapping
	 * <p>
	 * format in dat file is : fromDssFile, pathname, toDssFile, pathname
	 */
	public void transferDssData(String type)
	{
		int num = 0;
		System.out.println("Transfering Data For: " + type.toUpperCase());
		if(type.equalsIgnoreCase(_b2String))
		{
			num = _b2ToFile.size();
			for(int i = 0; i < num; i++)
			{
				DataReference ref = DataReference.createExpanded((DataReference) _b2Ref.elementAt(i), _tw);
				ref.reloadData();
				DSSUtil.writeData((String) _b2ToFile.elementAt(i), (String) _b2NewPath.elementAt(i), ref.getData());
				if(DEBUG)
				{
					System.out.println("Transferring to: " + _b2ToFile.elementAt(
							i) + " New Path: " + _b2NewPath.elementAt(i));
				}
			}
		}
		if(type.equalsIgnoreCase(_ewaString))
		{
			num = _ewaToFile.size();
			for(int i = 0; i < num; i++)
			{
				DataReference ref = DataReference.createExpanded((DataReference) _ewaRef.elementAt(i), _tw);
				ref.reloadData();
				DSSUtil.writeData((String) _ewaToFile.elementAt(i), (String) _ewaNewPath.elementAt(i), ref.getData());
				if(DEBUG)
				{
					System.out.println("Transferring to: " + _ewaToFile.elementAt(
							i) + " New Path: " + _ewaNewPath.elementAt(i));
				}
			}
		}
	}

	/**
	 * Creates vectors in the first year of the run that hold the name of the files that recieve data
	 * What the new dss pathname is and the datarefences s
	 */
	public void readPosTransfer(String file, String type, int numyears)
	{
		Vector data = new Vector();

		CSVParser parser = new CSVParser(file);
		// read data till empty line
		while(true)
		{
			String[] fields = parser.nextLine();
			if(fields == null)
			{
				break;
			}
			data.addElement(fields);
		}
		parser.close();
		String fromFile = " ";
		String toFile = " ";
		Group[] g = new Group[numyears];
		String[] todvs = new String[numyears];
		System.out.println("Reading Transfer File.");
		boolean todv = false;
		for(Enumeration e = data.elements(); e.hasMoreElements(); )
		{
			String[] s = (String[]) e.nextElement();
			if(s[0].indexOf("*") == 0)
			{
				todv = s[2].toUpperCase().endsWith("DV.DSS") && numyears > 1;
				for(int i = 0; i < numyears; i++)
				{
					if(numyears == 1)
					{
						fromFile = s[1];
					}
					else
					{
						int dir = s[1].lastIndexOf("\\");
						String dirname = s[1].substring(0, dir + 1);
						fromFile = dirname + "POSITION" + new Integer(i + 1).toString() + "DV.DSS";
					}
					if(DEBUG)
					{
						System.out.println("From file: " + fromFile);
					}
					g[i] = AppUtils.openDSSFile(fromFile);
					if(todv)
					{
						int dir = s[2].lastIndexOf("\\");
						String dirname = s[2].substring(0, dir + 1);
						todvs[i] = dirname + "POSITION" + new Integer(i + 1).toString() + "DV.DSS";
						if(DEBUG)
						{
							System.out.println("Alt. to DV: " + todvs[i]);
						}
					}
					toFile = s[2];
					if(DEBUG)
					{
						System.out.println("to file: " + toFile);
					}
				}
			}
			else
			{
				for(int i = 0; i < numyears; i++)
				{
					String gname = g[i].toString().substring(7);
					File f = new File(gname);
					if(f.exists())
					{
						Group gmod = (Group) g[i].clone();
						gmod.filterBy(s[0]);
						DataReference ref = gmod.getDataReference(0);
						if(type.equalsIgnoreCase(_b2String))
						{
							if(todv)
							{
								_b2ToFile.addElement(todvs[i]);
							}
							else
							{
								_b2ToFile.addElement(toFile);
							}
							_b2NewPath.addElement(s[1]);
							_b2Ref.addElement(ref);
						}
						else if(type.equalsIgnoreCase(_ewaString))
						{
							if(todv)
							{
								_ewaToFile.addElement(todvs[i]);
							}
							else
							{
								_ewaToFile.addElement(toFile);
							}
							_ewaNewPath.addElement(s[1]);
							_ewaRef.addElement(ref);
						}
					}
					else
					{
						if(type.equalsIgnoreCase(_b2String))
						{
							_b2ToFile.addElement("");
							_b2NewPath.addElement("");
							_b2Ref.addElement("");
						}
						else if(type.equalsIgnoreCase(_ewaString))
						{
							_ewaToFile.addElement("");
							_ewaNewPath.addElement("");
							_ewaRef.addElement("");
						}
					}
				}
			}
		}
		g = null;
	}

	/**
	 * Transfers dss data from one file to another with pathname mapping
	 * <p>
	 * format in dat file is : fromDssFile, pathname, toDssFile, pathname
	 */
	public void transferPositionData(String type, int numyear, int posyear)
	{
		int num = 0;
		System.out.println("Transfering Data For: " + type.toUpperCase());
		if(type.equalsIgnoreCase(_b2String))
		{
			num = _b2ToFile.size();
			if(DEBUG)
			{
				System.out.println("Num is: " + num);
			}
			int it = 0;
			for(int i = posyear; i < num; i = posyear + numyear * it)
			{
				if(DEBUG)
				{
					System.out.println("i " + i);
				}
				DataReference ref = DataReference.createExpanded((DataReference) _b2Ref.elementAt(i), _tw);
				ref.reloadData();
				DSSUtil.writeData((String) _b2ToFile.elementAt(i), (String) _b2NewPath.elementAt(i), ref.getData());
				if(DEBUG)
				{
					System.out.println("Data to File: " + _b2ToFile.elementAt(i));
				}
				it++;
			}
		}
		if(type.equalsIgnoreCase(_ewaString))
		{
			num = _ewaToFile.size();
			if(DEBUG)
			{
				System.out.println("Num is: " + num);
			}
			int it = 0;
			for(int i = posyear; i < num; i = posyear + numyear * it)
			{
				if(DEBUG)
				{
					System.out.println("i " + i);
				}
				DataReference ref = DataReference.createExpanded((DataReference) _ewaRef.elementAt(i), _tw);
				ref.reloadData();
				DSSUtil.writeData((String) _ewaToFile.elementAt(i), (String) _ewaNewPath.elementAt(i), ref.getData());
				if(DEBUG)
				{
					System.out.println("Data to File: " + _ewaToFile.elementAt(i));
				}
				it++;
			}
		}
	}

	public void clearVectors()
	{
		if(DEBUG)
		{
			System.out.println("clear");
		}
		_b2ToFile.removeAllElements();
		_b2NewPath.removeAllElements();
		_b2Ref.removeAllElements();
		_ewaToFile.removeAllElements();
		_ewaNewPath.removeAllElements();
		_ewaRef.removeAllElements();
	}


	private TimeWindow createTimeWindow(String st, String et)
	{
		TimeFactory tf = TimeFactory.getInstance();
		Time stime = tf.createTime(st);
		Time etime = tf.createTime(et);
		return tf.createTimeWindow(stime, etime);
	}


	/**
	 * Test method
	 */
	public void run(String[] studies, String[] transfer, int[] years, String runtype, String options,
					boolean position, int numyears)
	{
		int incyr;
		//		int stat;
		Hashtable monthIndex = new Hashtable(12);
		monthIndex.put("JAN", new Integer(1));
		monthIndex.put("FEB", new Integer(2));
		monthIndex.put("MAR", new Integer(3));
		monthIndex.put("APR", new Integer(4));
		monthIndex.put("MAY", new Integer(5));
		monthIndex.put("JUN", new Integer(6));
		monthIndex.put("JUL", new Integer(7));
		monthIndex.put("AUG", new Integer(8));
		monthIndex.put("SEP", new Integer(9));
		monthIndex.put("OCT", new Integer(10));
		monthIndex.put("NOV", new Integer(11));
		monthIndex.put("DEC", new Integer(12));

		String[] mNames = {"D1485", "D1641", "B2", "EWA"};
		String begmon = "OCT";
		String endmon = "SEP";
		Integer bmo = (Integer) monthIndex.get(begmon);
		Integer emo = (Integer) monthIndex.get(endmon);

		if(emo.intValue() - bmo.intValue() >= 0)
		{
			incyr = 0;
		}
		else
		{
			incyr = 1;
		}
		System.out.println("Increment " + incyr);
		int byr = years[0];
		int eyr = years[1];

		// load all studies
		int nstudy = 0;
		String b2transfile = "";
		String ewatransfile = "";
		String tol = "";
		//		String syear = "";
		int syeari;
		boolean diffyear = false;
		if(runtype.equals("B2"))
		{
			nstudy = 3;
			b2transfile = transfer[0];
			tol = options.toUpperCase();
			syeari = byr;
			System.out.println("Running B2 Study.");
		}
		else if(runtype.equals("EWA"))
		{
			System.out.println("Running EWA Study.");
			nstudy = 4;
			b2transfile = transfer[0];
			ewatransfile = transfer[1];
			tol = options.toUpperCase();
			syeari = byr;
		}
		else
		{
			System.out.println("Batch file error.");
			return;
		}
		if(syeari != 1921)
		{
			byr = syeari;
			diffyear = true;
		}
		String startdata = "31" + begmon + byr + " 2400";
		if(numyears > 1 && position)
		{
			eyr += numyears;
		}
		String stopdata = "30" + endmon + eyr + " 2400";
		_tw = createTimeWindow(startdata, stopdata);
		System.out.println(begmon + byr + " - " + endmon + eyr);

		Study[] sty = new Study[nstudy];
		for(int i = 0; i < nstudy; i++)
		{
			sty[i] = new Study();
			try
			{
				sty[i].load(studies[i]);
				sty[i].setStartMonth(begmon);
				sty[i].setStopMonth(endmon);
				sty[i].setAddXaOptions(tol);
				sty[i].setPosAnalysisOption(
						new Boolean(true)); //I believe this simply avoids the NORMAL COMPLETION window.
			}
			catch(IOException ioe)
			{
				throw new RuntimeException(ioe.getMessage());
			}
		}
		// set proper start and stop dates, save and run studies, transfer dss data
		boolean year0 = true;
		long runstart = System.currentTimeMillis();
		int dvyear = 0;
		boolean changedv = true;
		String[] inits = new String[nstudy];
		String[] fpart = new String[nstudy];
		String[] dvfiles = new String[nstudy * numyears];
		clearVectors();
		for(int i = 0; i < nstudy; i++)
		{
			inits[i] = sty[i].getInitFile();
			fpart[i] = sty[i].getInitFileFPart();
		}
		for(int i = byr; i < eyr; i++)
		{
			if(position)
			{
				if(numyears == 0)
				{
					JOptionPane.showMessageDialog(null, "Specify number of years",
							"Need to Specify the number of years", JOptionPane.ERROR_MESSAGE);
					return;
				}
				if(numyears > 1 && i == byr)
				{
					for(int s = 0; s < nstudy; s++)
					{
						String dvname = sty[s].getDvFile();
						if(DEBUG)
						{
							System.out.println(s);
						}
						for(int y = 0; y < numyears; y++)
						{
							int dir = dvname.lastIndexOf("\\");
							String dirname = dvname.substring(0, dir + 1);
							dvfiles[s * numyears + y] = dirname + "POSITION" + new Integer(y + 1).toString() + "DV.DSS";
							if(DEBUG)
							{
								System.out.println(dvfiles[s * numyears + y] + " " + new Integer(s * numyears + y));
							}
						}
					}
				}
				int esyr = byr + numyears - 1;
				for(int yr = 0; yr < numyears; yr++)
				{
					int syr = i + yr;
					for(int is = 0; is < sty.length; is++)
					{
						_study = sty[is];
						_study.setStartYear(new Integer(syr));
						_study.setStopYear(new Integer(syr + 1));
						if(yr == 0)
						{
							if(DEBUG)
							{
								System.out.println("Setting Init");
							}
							_study.setInitFile(inits[is]);
							_study.setInitFileFPart(fpart[is]);
							_study.setPositionStartYear(new Boolean(true));
						}
						else
						{
							if(DEBUG)
							{
								System.out.println("Setting DV Init");
							}
							_study.setInitFile(sty[nstudy - 1].getDvFile());
							_study.setInitFileFPart(sty[nstudy - 1].getName());
							_study.setPositionStartYear(new Boolean(false));
						}
						System.out.println("Position Start Year: " + _study.getPositionStartYear());
						if(numyears > 1)
						{
							_study.setDvFile(dvfiles[is * numyears + dvyear]);
							if(DEBUG)
							{
								System.out.println(dvfiles[is * numyears + dvyear]);
							}
						}
						saveStudyFile(_study);
						if(newerFiles(_study.getWreslFile()))
						{
							if(parseFiles() != 0)
							{
								return;
							}
							if(compile() != 0)
							{
								return;
							}
							if(link() != 0)
							{
								return;
							}
						}
						System.out.println("Running " + mNames[is] + " module from " + _study.getStartMonth()
								+ _study.getStartYear() + " to " + _study.getStopMonth() + _study.getStopYear());
						if(execute() != 0)
						{
							return;
						}


						long transstart = System.currentTimeMillis();
						if(is == 1)
						{
							if(DEBUG)
							{
								System.out.println("Transfering for dv: " + dvyear + " Year is: " + syr + " yr " + yr);
							}
							if(year0)
							{
								readPosTransfer(b2transfile, _b2String, numyears);
							}
							transferPositionData(_b2String, numyears, dvyear);
						}
						if(is == 2 && nstudy == 4)
						{
							if(DEBUG)
							{
								System.out.println("Transfering for dv: " + dvyear + "Year is: " + i);
							}
							if(year0)
							{
								readPosTransfer(ewatransfile, _ewaString, numyears);
							}
							transferPositionData(_ewaString, numyears, dvyear);
						}
						long transstop = System.currentTimeMillis();
						System.out.println("Transfer Time " + (transstop - transstart) / 1000);
					}
					year0 = false;
				}
				if(dvyear == numyears - 1)
				{
					dvyear = 0;
					changedv = false;
				}
				else
				{
					dvyear++;
					changedv = true;
				}
				if(changedv && byr <= i && esyr >= i)
				{
					clearVectors();
					year0 = true;
				}

			}
			else
			{
				for(int is = 0; is < sty.length; is++)
				{
					_study = sty[is];
					_study.setStartYear(new Integer(i));
					_study.setStopYear(new Integer(i + incyr));
					if(i != byr || diffyear)
					{
						_study.setInitFile(sty[nstudy - 1].getDvFile());
						_study.setInitFileFPart(sty[nstudy - 1].getName());
					}
					saveStudyFile(_study);
					//if (i==byr) { // wreslmaker only initialized with newerFiles method -- change later
					if(newerFiles(_study.getWreslFile()))
					{
						if(parseFiles() != 0)
						{
							return;
						}
						if(compile() != 0)
						{
							return;
						}
						if(link() != 0)
						{
							return;
						}
					}
					//}
					System.out.println("Running " + mNames[is] + " module from " + _study.getStartMonth()
							+ _study.getStartYear() + " to " + _study.getStopMonth() + _study.getStopYear());
					if(execute() != 0)
					{
						return;
					}
					long transstart = System.currentTimeMillis();
					if(is == 1)
					{
						if(year0)
						{
							readTransferFile(b2transfile, _b2String);
						}
						transferDssData(_b2String);
					}
					if(is == 2 && nstudy == 4)
					{
						if(year0)
						{
							readTransferFile(ewatransfile, _ewaString);
						}
						transferDssData(_ewaString);
					}
					long transstop = System.currentTimeMillis();
					System.out.println("Transfer Time " + (transstop - transstart) / 1000);
				}
				year0 = false;
			}
		}
		clearVectors();
		long runstop = System.currentTimeMillis();
		System.out.println("Run Time " + (runstop - runstart) / 1000);
		return;
	}

	/**
	 * Main method

	 public static void main(String args[]) {
	 /*
	 JFrame f = new JFrame("CALSIM B2-EWA Modeler");
	 Container pane = f.getContentPane();
	 pane.setLayout(new GridLayout(4,3));
	 pane.add(new JTextField(32));
	 pane.add(new JButton("Browse"));
	 pane.add(new JTextField(32));
	 pane.add(new JButton("Browse"));
	 pane.add(new JTextField(32));
	 pane.add(new JButton("Browse"));
	 pane.add(new JTextField(32));
	 pane.add(new JButton("Browse"));
	 f.setSize(450,450);
	 f.show();
	 *//*
    MultiStudyRunner runner = new MultiStudyRunner();
    if (args.length > 1) runner.test(args);
    else runner.transferDssData(args[0]);
  }
  */
}

