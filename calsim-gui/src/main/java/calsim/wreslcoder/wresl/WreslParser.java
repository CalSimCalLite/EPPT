/*
 * Copyright (c) 2019
 * California Department of Water Resources
 * All Rights Reserved.  DWR PROPRIETARY/CONFIDENTIAL.
 * Source may not be released without written approval from DWR
 */

/* Generated By:JavaCC: Do not edit this line. WreslParser.java */
package calsim.wreslcoder.wresl;
//CBimport java.util.*;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

/**
 * WreslParser class for Calsim. Contains the entire WRESL language definition.
 *
 * @author Armin Munevar
 * @version $Id: wresl.jj,v 1.1.2.17.2.1 2002/05/02 01:06:28 adraper Exp $
 */
public class WreslParser implements WreslParserConstants
{
	public static String version = "Wresl Parser Version 0.97";
	public static File _lastFileParsed; // CB added
	static java.io.PrintWriter goals, defines, globalDefines, weights, dssInit, externals, externalsLib;
	static java.io.PrintWriter globalCodeSelect, globalDssInit, globalExternals, globalExternalsLib;
	static java.io.PrintWriter _controlDefines, localDefines;
	static ReportWriter svReport;
	//  static InitSVWriter initSVReport;
	//  static DumpSVWriter dumpSVReport;
	static ReservedWords reservedList;    // predefined variables
	static UniqueList tableDefList;       // stores rdbms table names
	static UniqueList tagList;                            // stores goal names
	// GLOBAL lists
	static UniqueList valueDefList;       // stores names of value variables
	static UniqueList tsDefList;                          // stores names of timeseries variables
	static UniqueList dvarList;                           // stores names of decision variables
	static UniqueList dllList;
	// LOCAL lists
	static UniqueList valueDefLocalList;          // stores names of value variables
	static UniqueList tsDefLocalList;                     // stores names of timeseries variables
	static UniqueList dvarLocalList;                      // stores names of decision variables
	static Hashtable fileList;
	static Hashtable tsParamList;
	static Hashtable externalList;
	static Hashtable sequenceList;
	static Hashtable seqConditionList;
	static Hashtable goalLocalList;
	static Hashtable includeLocalList;
	static PrintWriter logger;
	static String rootDirectory;
	static String _currentModel;
	static Integer _currentOrder;
	static String _currentOrderString;
	static String _currentIncludeFile = " ";
	static boolean _fileIsLocal = false;
	private static final String[] tokenImage =
			{
					"<EOF>",
					"\" \"",
					"\"\\t\"",
					"\"\\n\"",
					"\"\\r\"",
					"<SL_COMMENT>",
					"<ML_COMMENT>",
					"\"lhs\"",
					"\"rhs\"",
					"\"lhs<rhs\"",
					"\"lhs>rhs\"",
					"\"unbounded\"",
					"\"penalty\"",
					"<CONSTRAIN>",
					"\"sequence\"",
					"\"model\"",
					"\"order\"",
					"\"include\"",
					"\"value\"",
					"\"kind\"",
					"\"units\"",
					"\"convert\"",
					"\"alias\"",
					"\"select\"",
					"\"where\"",
					"\"desc\"",
					"\"header\"",
					"\"timeseries\"",
					"\"from\"",
					"\"maximum\"",
					"\"minimum\"",
					"\"mean\"",
					"\"linear\"",
					"\"unknown\"",
					"\"use\"",
					"\"given\"",
					"\"result\"",
					"\"std\"",
					"\"always\"",
					"\"goal\"",
					"\"goalset\"",
					"\"define\"",
					"\"condition\"",
					"\"sum\"",
					"\"external\"",
					"\"case\"",
					"\"lower\"",
					"\"upper\"",
					"\"integer\"",
					"\"+\"",
					"\"-\"",
					"\"*\"",
					"\"/\"",
					"\".and.\"",
					"\".or.\"",
					"\".not.\"",
					"\">\"",
					"\"<\"",
					"\"=\"",
					"\">=\"",
					"\"<=\"",
					"\"==\"",
					"\"/=\"",
					"\"objective\"",
					"\"abs\"",
					"\"int\"",
					"\"nint\"",
					"\"real\"",
					"\"mod\"",
					"\"exp\"",
					"\"log\"",
					"\"log10\"",
					"\"sqrt\"",
					"\"max\"",
					"\"min\"",
					"\"pow\"",
					"\"range\"",
					"\"date\"",
					"\"array\"",
					"\"fillarray\"",
					"\"local\"",
					"\"global\"",
					"<DAYMONTH>",
					"<MONTHYEAR>",
					"<DAYMONTHYEAR>",
					"<DAY>",
					"<MONTH>",
					"<YEAR>",
					"<CONSTANT>",
					"<DOUBLE>",
					"<DIGIT>",
					"<ID>",
					"<TIME_UNIT>",
					"<IDENTIFIER>",
					"<LETTER>",
					"<QUOTED_LITERAL>",
					"<DLL>",
					"\"{\"",
					"\"}\"",
					"\"[\"",
					"\"]\"",
					"\"(\"",
					"\",\"",
					"\")\"",
			};
	//CB added to eliminate error "..user-mapped section open.." (when two parsers have "claim" to the local defines file)
	static FileWriter _localDefinesFile;
	// CB added
	private static boolean _hideWarnings;
	// CB added
	private static boolean _hideProgressDetails;
	//CB added
	private static int _parseFileDelay = 0;
	//CB cannot do one parser with WreslParser in current form due to JavaCC controlling constructor code! */
	//CB  private static WreslParser _include; // CB added to eliminate error "..user-mapped section open.." (when two parsers have "claim" to one of the text files)
	private static Writer _writer = new Writer();  //CB added to eliminate error "..user-mapped section open.." (when two parsers have "claim" to one of the text files)
	final private int[] jj_la1 = new int[88];
	final private int[] jj_la1_0 = {0xc000, 0xc000, 0x0, 0x0, 0x0, 0x0, 0x20000, 0x20000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c40000, 0x0, 0x0, 0x0, 0x0, 0x840000, 0x840000, 0x0, 0x0, 0x0, 0x0, 0xe0000000, 0x0, 0x1000000, 0x0, 0x0, 0x0, 0x0, 0x200000, 0x2000000, 0x0, 0x0, 0x0, 0x2000000, 0x4000000, 0x0, 0x0, 0x800, 0x80000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x100, 0x200, 0x400, 0x600, 0x600, 0x3000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
	final private int[] jj_la1_1 = {0x0, 0x0, 0x0, 0x0, 0x400, 0x0, 0x80000380, 0x80000380, 0x0, 0x0, 0x80000380, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f820, 0x0, 0x0, 0x0, 0x2000, 0x2800, 0x800, 0x0, 0x0, 0x0, 0x0, 0x1, 0x8, 0x0, 0x0, 0x0, 0x4000000, 0x0, 0x0, 0x0, 0x0, 0x10000, 0xc020, 0x0, 0x0, 0xc000, 0xc000, 0x40000, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x40000, 0x0, 0x7000000, 0x2000, 0x2000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x600000, 0x600000, 0x840040, 0x800000, 0x7b000000, 0x40000, 0x40000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60000, 0x60000, 0x180000, 0x180000, 0x40000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2000, 0x42000,};
	final private int[] jj_la1_2 = {0x0, 0x0, 0x201c0000, 0x201c0000, 0x0, 0x201c0000, 0x4000, 0x4000, 0x30000, 0x0, 0x4000, 0x201c0000, 0x0, 0x30000, 0x0, 0x201c0000, 0x0, 0x201c0000, 0x201c0000, 0x0, 0x0, 0x0, 0x0, 0x201c0000, 0x0, 0x201c0000, 0x201c0000, 0x0, 0x0, 0x0, 0x0, 0x201c0000, 0x0, 0x80000000, 0x0, 0x0, 0x1000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x211c0fff, 0x0, 0x201c0000, 0x0, 0x30000, 0x0, 0x201c0000, 0x211c0fff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x201c0000, 0x0, 0x0, 0x211c1fff, 0x0, 0x0, 0x211c0fff, 0x211c2fff, 0x1c0000, 0x0, 0x0, 0x201c0000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x211c0fff, 0x201c0000, 0x211c0000, 0x201c0000, 0xfff, 0x201c0000, 0x201c0000, 0x30000, 0x0, 0x0, 0x211c0fff,};
	final private int[] jj_la1_3 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x8, 0x0, 0x8, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0x20, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x20, 0x20, 0x0, 0x40, 0x40, 0x0, 0x40, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0x20,};
	final private JJCalls[] jj_2_rtns = new JJCalls[4];
	public int includeLevel = 0; // for printing indents only
	public WreslParserTokenManager token_source;
	public Token token, jj_nt;
	public boolean lookingAhead = false;
	javax.swing.Timer _timer;                         //CB added to eliminate error "..user-mapped section open.." (when two parsers have "claim" to the local defines file)
	ASCII_CharStream jj_input_stream;
	private File parserInputPath;
	private int _numberCycles = 1;
	private boolean condIsAlways = false;
	private int jj_ntk;
	private Token jj_scanpos, jj_lastpos;
	private int jj_la;
	private boolean jj_semLA;
	private int jj_gen;
	private boolean jj_rescan = false;
	private int jj_gc = 0;
	private java.util.Vector jj_expentries = new java.util.Vector();
	private int[] jj_expentry;
	private int jj_kind = -1;
	private int[] jj_lasttokens = new int[100];
	private int jj_endpos;


	public WreslParser(java.io.InputStream stream)
	{
		jj_input_stream = new ASCII_CharStream(stream, 1, 1);
		token_source = new WreslParserTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for(int i = 0; i < 88; i++)
		{
			jj_la1[i] = -1;
		}
		for(int i = 0; i < jj_2_rtns.length; i++)
		{
			jj_2_rtns[i] = new JJCalls();
		}
	}

	public WreslParser(java.io.Reader stream)
	{
		jj_input_stream = new ASCII_CharStream(stream, 1, 1);
		token_source = new WreslParserTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for(int i = 0; i < 88; i++)
		{
			jj_la1[i] = -1;
		}
		for(int i = 0; i < jj_2_rtns.length; i++)
		{
			jj_2_rtns[i] = new JJCalls();
		}
	}

	public WreslParser(WreslParserTokenManager tm)
	{
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for(int i = 0; i < 88; i++)
		{
			jj_la1[i] = -1;
		}
		for(int i = 0; i < jj_2_rtns.length; i++)
		{
			jj_2_rtns[i] = new JJCalls();
		}
	}

	/**
	 * Initializes parameters for a new parse
	 */
	public static void initParameters(String objPath, PrintWriter logStream,
									  boolean hideWarnings, boolean hideProgressDetails, int parseFileDelay)
			throws IOException
	{
		logger = logStream;
		rootDirectory = objPath;
		_hideWarnings = hideWarnings;
		_hideProgressDetails = hideProgressDetails;
		_parseFileDelay = parseFileDelay;
		reset();
	}

	/**
	 * Initializes the sequence output files
	 */
	public static void initOutput(String seqNumber, int ncycles) throws IOException
	{
		FileWriter goalsFile, definesFile, weightsFile, localDefinesFile;

		goalsFile = new FileWriter(rootDirectory + "\\goals" + seqNumber + ".txt");
		definesFile = new FileWriter(rootDirectory + "\\defines" + seqNumber + ".txt");
		weightsFile = new FileWriter(rootDirectory + "\\weights" + seqNumber + ".txt");
		//CB    localDefinesFile = new FileWriter(rootDirectory + "\\deflocal.txt");
		//CB changed to eliminate error "..user-mapped section open.." (when two parsers have "claim" to one of the text files)
		_localDefinesFile = new FileWriter(rootDirectory + "\\deflocal.txt");

		defines = new PrintWriter(new BufferedWriter(definesFile));
		goals = new PrintWriter(new BufferedWriter(goalsFile));
		weights = new PrintWriter(new BufferedWriter(weightsFile));
		//CB    localDefines = new PrintWriter(new BufferedWriter(localDefinesFile), false);
		//CB changed to eliminate error "..user-mapped section open.." (when two parsers have "claim" to one of the text files)
		localDefines = new PrintWriter(new BufferedWriter(_localDefinesFile), false);
		resetDefs(ncycles);
	}

	/**
	 * Writes out all defines and resets the defines local lists
	 */
	public static void resetDefs(int ncycles) throws IOException
	{
		valueDefLocalList.removeAllElements();
		tsDefLocalList.removeAllElements();
		dvarLocalList.removeAllElements();
	}

	/**
	 * Opens global files which will contain the sub-files for each sequence
	 */
	public static void openGlobalFiles() throws IOException
	{
		FileWriter globalCodeSelectFile, globalDefinesFile, globalDssInitFile, globalStateReportFile,
				globalExternalsFile, globalExternalsLibFile;

		globalCodeSelectFile = new FileWriter(rootDirectory + "\\code.f90");
		globalDefinesFile = new FileWriter(rootDirectory + "\\defines00.txt");
		globalDssInitFile = new FileWriter(rootDirectory + "\\dss_init.f90");
		globalExternalsFile = new FileWriter(rootDirectory + "\\externals.rsp");
		globalExternalsLibFile = new FileWriter(rootDirectory + "\\externalsLib.rsp");

		globalCodeSelect = new PrintWriter(new BufferedWriter(globalCodeSelectFile));
		globalDefines = new PrintWriter(new BufferedWriter(globalDefinesFile), false);
		globalDssInit = new PrintWriter(new BufferedWriter(globalDssInitFile));
		globalExternals = new PrintWriter(new BufferedWriter(globalExternalsFile));
		globalExternalsLib = new PrintWriter(new BufferedWriter(globalExternalsLibFile));

		//    FileWriter initSVReportFile = new FileWriter(rootDirectory + "\\init_reader.f90");
		//    initSVReport = new InitSVWriter(new PrintWriter(new BufferedWriter(initSVReportFile)));
		//    FileWriter dumpSVReportFile = new FileWriter(rootDirectory + "\\dump_writer.f90");
		//    dumpSVReport = new DumpSVWriter(new PrintWriter(new BufferedWriter(dumpSVReportFile)));
		FileWriter svReportFile = new FileWriter(rootDirectory + "\\report_writer.f90");
		svReport = new ReportWriter(new PrintWriter(new BufferedWriter(svReportFile)));
	}

	/**
	 * Begins the global code and report_writer file statements
	 */
	public static void beginGlobalCode()
	{
		globalCodeSelect.println("SUBROUTINE CODE(number,needToSimulate,p)");
		globalCodeSelect.println(" ");
		globalCodeSelect.println("USE GLOBAL");
		globalCodeSelect.println("IMPLICIT NONE");
		globalCodeSelect.println("INTEGER :: number, p");
		globalCodeSelect.println("LOGICAL, INTENT(INOUT) :: needToSimulate");
		globalCodeSelect.println("INTEGER :: goal_count = 1");
		globalCodeSelect.println("EXTERNAL CODE00");

		beginDssInitializer();
	}

	/**
	 * Adds external statements to the global code file
	 */
	public static void externalGlobalCode(String number)
	{
		globalCodeSelect.println("EXTERNAL CODE" + number);
	}

	/**
	 * Adds conditional statements to the global code and report_writer files
	 */
	public static void conditionGlobalCode(String number, String cond)
	{
		globalCodeSelect.println("IF (number==" + number + ") needToSimulate=" + cond);
		globalCodeSelect.println(
				"IF (number==" + number + ".and.(" + cond + ")) CALL CODE" + number + "(p, goal_count)");
	}
	//******************************************************************************************
	//******************************************************************************************

	/**
	 * Ends the global code and report_writer file statements and closes files
	 */
	public static void endGlobalCode()
	{
		globalCodeSelect.println("IF (number==0) THEN");
		globalCodeSelect.println("\u0009CALL CODE00(p)");
		globalCodeSelect.println("\u0009goal_count = 1");
		globalCodeSelect.println("END IF");
		globalCodeSelect.println("END SUBROUTINE");
		globalCodeSelect.close();

		globalDefines.close();

		endDssInitializer();

		globalExternals.close();
		globalExternalsLib.close();
		//
		//    initSVReport.close();
		//    dumpSVReport.close();
		svReport.close();
	}

/*TOKEN :			//Added to implement array expression
{
  < NEGCONSTANT: <SUBTRACT> <CONSTANT> >
}*/


	// *****************************************
	// THE WRESL LANGUAGE GRAMMAR STARTS HERE *
	// *****************************************

	/**
	 * Initializes and resets the symbol tables.
	 */
	private static void reset()
	{
		tagList = new UniqueList();   // stores goal names
		tableDefList = new UniqueList();   // stores rdbms table definition names
		valueDefList = new UniqueList();   // stores value definition names
		valueDefLocalList = new UniqueList();   // stores value definition names
		tsDefList = new UniqueList();   // stores value definition names
		tsDefLocalList = new UniqueList();   // stores value definition names
		dvarList = new UniqueList();   // stores names of decision variables
		dllList = new UniqueList();  // stores names of imported dll's
		dvarLocalList = new UniqueList();   // stores names of decision variables
		reservedList = new ReservedWords();    // predefined variables
		fileList = new Hashtable(10);
		tsParamList = new Hashtable();
		externalList = new Hashtable();
		sequenceList = new Hashtable();
		seqConditionList = new Hashtable();
		goalLocalList = new Hashtable();
		includeLocalList = new Hashtable();
	}

	/**
	 * Writes the define statements for global and local variables at the current sequence
	 */
	public static void writeOutput() throws IOException
	{
		FileWriter localDefinesFile;
		String line = "";
		localDefines.close();
		BufferedReader fin1 = new BufferedReader(new FileReader(rootDirectory + "\\deflocal.txt"));
		line = fin1.readLine();
		while(line != null)
		{
			defines.println(line);
			line = fin1.readLine();
		}
		fin1.close();
		new File(rootDirectory, "\\deflocal.txt").delete();
		localDefinesFile = new FileWriter(rootDirectory + "\\deflocal.txt");
		localDefines = new PrintWriter(new BufferedWriter(localDefinesFile));
		return;
	}

	/**
	 * Closes all files, and also produces the state variable report writer
	 * subroutine. Merges the global and local svar defines for the current sequence.
	 */
	public static void closeOutput(int ncycles) throws IOException
	{
		//    String line = new String();
		UniqueList mergeDefList = new UniqueList();
		//    String f = new String();

/*CB    defines.close();
    weights.close();
    goals.close();
    globalDefines.flush();
    localDefines.close();
*/
		closeLocalFiles();

		for(Enumeration e = valueDefList.elements(); e.hasMoreElements(); )
		{
			mergeDefList.newItem(e.nextElement());
		}

		for(Enumeration e = valueDefLocalList.elements(); e.hasMoreElements(); )
		{
			mergeDefList.newItem(e.nextElement());
		}
		//
		svReport.mkReport(valueDefLocalList, _currentOrder.intValue());
		//    initSVReport.mkReport(valueDefLocalList,_currentOrder.intValue());
		//    dumpSVReport.mkReport(valueDefLocalList,_currentOrder.intValue());
		if(_currentOrder.intValue() == ncycles)
		{
			svReport.mkReport(valueDefList, 0);
			//      initSVReport.mkReport(valueDefList,0);
			//      dumpSVReport.mkReport(valueDefList,0);
		}
		return;
	}

	public static void closeLocalFiles()
	{
		defines.close();
		weights.close();
		goals.close();
		globalDefines.flush();
		localDefines.close();
	}

	public static void closeAllFiles()
	{
		defines.close();
		weights.close();
		goals.close();
		globalDefines.close();
		weights.close();
		localDefines.close();
		if(dssInit != null)
		{
			dssInit.close();
		}
		if(externals != null)
		{
			externals.close();
		}
		if(externalsLib != null)
		{
			externalsLib.close();
		}
		if(globalCodeSelect != null)
		{
			globalCodeSelect.close();
		}
		if(globalDssInit != null)
		{
			globalDssInit.close();
		}
		if(globalExternals != null)
		{
			globalExternals.close();
		}
		if(globalExternals != null)
		{
			globalExternalsLib.close();
		}
	}

	/**
	 * Writes the beginning statements for the DSS init file
	 */
	private static void beginDssInitializer()
	{
		globalDssInit.println("! Automatically generated by WreslParser");
		globalDssInit.println("subroutine dss_init");
		globalDssInit.println("use code_utils");
		globalDssInit.println("call allocateTables");
	}

	/**
	 * Writes the ending statements for the DSS init file
	 */
	private static void endDssInitializer()
	{
		int nDvar = dvarList.size();
		int nTS = tsDefList.size();
		//DEBUGGING
		//Global
/*    System.out.println("(global) dvarList size = " + dvarList.size());
    System.out.println("(global) valueDefList size = " + valueDefList.size());
    System.out.println("(global) tsDefList size = " + tsDefList.size());
    //Local
    System.out.println("dvarLocalList size " + dvarLocalList.size());
    System.out.println("valueDefLocalList size " + valueDefLocalList.size());
    System.out.println("tsParamList size = " + tsParamList.size());
    System.out.println("tsDefLocalList size = " + tsDefLocalList.size());
    System.out.println("goalLocalList size = " + goalLocalList.size());
    System.out.println("tagList size = " + tagList.size()); */

		globalDssInit.println("contains");
		globalDssInit.println("  subroutine allocateTables");
		globalDssInit.println("  use code_utils");
		globalDssInit.println("  call dss_init_tables(" + nDvar + "," + nTS + ")");
		globalDssInit.println("  end subroutine allocateTables");
		globalDssInit.println("end subroutine");
		globalDssInit.close();
	}

	/**
	 * Adds .wresl if not already present in file name
	 *
	 * @param name the Wresl file name
	 * @return if <i>name</i> does not end in <b>.wresl</b>, then
	 * <i>name</i>.wresl, otherwise <i>name</i>
	 */
	public static String nameWithExtension(String name)
	{
		String extension = ".wresl";
		if(name.toLowerCase().endsWith(extension))
		{
			return name;
		}
		else
		{
			return name.concat(extension);
		}
	}

	/**
	 *
	 */
	public int getNumberOfWreslCycles()
	{
		return _numberCycles;
	}

	/**
	 * Writes the sole condition term for the define and goal .txt files
	 */
	private void soleCondition(PrintWriter s)
	{
		s.println("1                SoleCondition");
		s.println("always");
	}

	/**
	 * Writes the no more case term for the define and goal .txt files
	 */
	private void noMoreCases(PrintWriter s)
	{
		s.println("99999            No more cases");
	}

	/**
	 * Handles all the include file info. Starts a new parser for each new file.
	 * Keeps track of the include levels.
	 */
	void includeFile(Token t) throws ParseException
	{
		if(includeLevel > 10)  // this is an arbitrary number and may be increased
		{
			throw wreslError(t, "Hmm.  Including too many files!");
		}
		String fname = nameWithExtension(t.image.substring(1, t.image.length() - 1));
		File incFile = new File(parserInputPath.getParent(), fname);

		FileInputStream f = null;
		try
		{
			f = new FileInputStream(incFile);
			//CB added block to allow user to specify parse delay to prevent the user-mapped section open error sometime seen depending on the computer
			synchronized(this)
			{
				try
				{
					if(_parseFileDelay == 0)
					{
						_parseFileDelay = 1;
					}
					wait(_parseFileDelay);
				}
				catch(InterruptedException ie)
				{
				}
			}

			_lastFileParsed = incFile;
			WreslParser include = new WreslParser(f);
			//CB tried to make one parser (but cannot) to try to fix error - "...user-mapped section is open"
/*      if (_include == null)
    	  _include = new WreslParser(f);
      else
    	  _include.setNewFile(f);  //CB cannot do with WreslParser in current form do to JavaCC controlling constructor code! */

			include.includeLevel = includeLevel + 1;
			include.identify(incFile);
			include.CompilationUnit();
			try
			{     // if token error, attempts to go send parser back to StudyUnit to catch error
				int byt1 = f.read(); // must access a method of f - JAVA bug  (yes)
				include.StudyUnit();
				include = null; //CB added lines to try to fix error - "...user-mapped section is open"  I.E, file is locked message on some machines
				if(f != null)
				{ //CB
					f.close();     //CB
					f = null;      //CB
					System.gc();   //CB
				}
			}
			catch(IOException ie)
			{ // must catch IOException otherwise no error will be caught - JAVA bug
			}
		}
		catch(FileNotFoundException e)
		{
			throw wreslError(t, "Can't open include file " + incFile.getAbsolutePath());
		}
		finally
		{
			if(f != null)
			{
				try
				{
					f.close();
					f = null;  //CB added lines to try to fix error - "...user-mapped section is open"  I.E, file is locked message on Nazrul's machine
					System.gc(); //CB
				}
				catch(IOException ie)
				{
					// swallow
				}
			}
		}
	}

	/**
	 * Makes string exactly 32 chars long, Fortran-style
	 */
	StringBuffer make32(String e)
	{
		StringBuffer sb = new StringBuffer(e);
		sb.append("                                ").setLength(32);
		return sb;
	}

	/**
	 * Makes a Fortran Real from a string
	 */
	void makeReal(StringBuffer e)
	{
		Float f;
		try
		{
			f = new Float(e.toString());
		}
		catch(NumberFormatException nn)
		{
			return;
		}
		e.setLength(0);
		e.append(f);
	}

	/**
	 * Identifies the source file to utility portions of the parser.
	 * This is not available to the JavaCC user by
	 * other means because components of ASCII_CharStream are private.
	 * Also, adds its name to a static list of files
	 * and their modification dates
	 *
	 * @param curFile The name of the file that is input to this parser
	 */
	public void identify(File curFile)
	{
		parserInputPath = curFile;
		fileList.put(new Long(curFile.lastModified()), curFile.getPath());
		if(!_hideProgressDetails)
		{
			for(int i = 0; i < includeLevel; i++)
			{
				logger.print("    ");
			}
			logger.println(curFile.getPath() + ":  ");
		}
	}

	/**
	 * Retrieves a list of input filenames that are newer than the given one
	 *
	 * @param comparisonFileName A file to compare modification dates against
	 * @return a Vector of Strings naming files that are newer
	 */
	public Vector newerFiles(String comparisonFileName)
	{
		Long comparisonTime = new Long(new File(comparisonFileName).lastModified());
		Vector newOnes = new Vector();
		Enumeration listOfTimes = fileList.keys();
		Long t;
		while(listOfTimes.hasMoreElements())
		{
			t = (Long) listOfTimes.nextElement();
			if(t.longValue() > comparisonTime.longValue())
			{
				newOnes.addElement(fileList.get(t));
			}
		}
		return newOnes;
	}

	//****************************************************************************
	//The following methods were added to develop date range logical expressions
	// ***************************************************************************
	//Method checkDate inserts a "0" to the front of the date where necessary
	public String checkDate(String image, int length)
	{

		StringBuffer temp = new StringBuffer(image);

		if(temp.length() == length - 1)
		{
			temp.insert(0, "0");
		}

		return temp.toString();
	}

	//Method changeToWaterYear converts a calendar year to a wateryear given the
	//wateryear month index.
	public int changeToWaterYear(int year, int month)
	{
		if(month >= 1 && month <= 3)
		{
			year++;
		}
		return year;
	}

	//Method createMonthRange creates a month range logical expression
	public String createMonthRange(Token var, String beg, String end) throws ParseException
	{

		int begMonth, endMonth;
		String e = "";

		begMonth = new Integer(beg).intValue();
		endMonth = new Integer(end).intValue();

		if(Math.min(begMonth, endMonth) < 1 || Math.max(begMonth, endMonth) > 12)
		{
			throw wreslError(var, "Illegal bounds in month range.");
		}
		else if(endMonth >= begMonth)
		{
			e = "(date%month >= " + begMonth + " .and. date%month <= " + endMonth + ")";
		}
		else
		{
			e = "(.not. (date%month > " + endMonth + " .and. date%month < " +
					begMonth + "))";
		}

		return e;
	}

	//Method createDayRange creates a day range logical expression
	public String createDayRange(Token var, String beg, String end) throws ParseException
	{

		int begDay, endDay;
		String e = "";

		begDay = new Integer(beg).intValue();
		endDay = new Integer(end).intValue();

		if(Math.min(begDay, endDay) < 1 || Math.max(begDay, endDay) > 31)
		{
			throw wreslError(var, "Illegal bounds in day range.");
		}
		else if(endDay >= begDay)
		{
			e = "(date%day >= " + begDay + " .and. date%day <= " + endDay + ")";
		}
		else
		{
			e = "(.not. (date%day > " + endDay + " .and. date%day < " + begDay + "))";
		}

		return e;
	}

	//Method createOrdinaryRange creates a non-time oriented range
	public String createOrdinaryRange(String var, String beg, String end)
	{

		String e = "";

		e = "(" + var + " >= " + beg + " .and. " + var + " <= " + end + ")";

		return e;
	}

	//Method createDayMonthRange creates a day-month range logical expression
	public String createDayMonthRange(String beg, String end)
	{

		int begDay, endDay, begMonth, endMonth;
		StringBuffer e = new StringBuffer();

		begDay = new Integer(beg.substring(0, 2)).intValue();
		begMonth = new Integer(reservedList.fortranExpr(beg.substring(2, 5))).intValue();

		endDay = new Integer(end.substring(0, 2)).intValue();
		endMonth = new Integer(reservedList.fortranExpr(end.substring(2, 5))).intValue();

		if(endMonth > begMonth)
		{
			e.append("((date%month == " + begMonth + " .and. date%day >= " +
					begDay + ") .or. (date%month > " + begMonth +
					" .and. date%month < " + endMonth + ") .or. (date%month == " +
					endMonth + " .and. date%day <= " + endDay + "))");
		}
		else if(endMonth == begMonth)
		{
			if(endDay >= begDay)
			{
				e.append("(date%month == " + begMonth + " .and. date%day >= " +
						begDay + " .and. date%day <= " + endDay + ")");
			}
			else
			{
				e.append("(.not. (date%month == " + begMonth + " .and. date%day > " +
						endDay + " .and. date%day < " + begDay + "))");
			}
		}
		else
		{
			e.append("(.not. ((date%month == " + endMonth + " .and. date%day > " +
					endDay + ") .or. (date%month > " + endMonth +
					" .and. date%month < " + begMonth + ") .or. (date%month == " +
					begMonth + " .and. date%day < " + begDay + ")))");
		}

		return e.toString();
	}

	//Method createMonthYearRange creates a month-year range logical expression
	public String createMonthYearRange(Token t, String beg, String end) throws ParseException
	{

		int begYear, endYear, begMonth, endMonth;
		StringBuffer e = new StringBuffer();

		begMonth = new Integer(reservedList.fortranExpr(beg.substring(0, 3))).intValue();
		begYear = changeToWaterYear(new Integer(beg.substring(3, 7)).intValue(), begMonth);

		endMonth = new Integer(reservedList.fortranExpr(end.substring(0, 3))).intValue();
		endYear = changeToWaterYear(new Integer(end.substring(3, 7)).intValue(), endMonth);

		if(endYear > begYear)
		{
			e.append("((date%wateryear == " + begYear + " .and. date%month >= " +
					begMonth + ") .or. (date%wateryear > " + begYear +
					" .and. date%wateryear < " + endYear + ") .or. (date%wateryear == " +
					endYear + " .and. date%month <= " + endMonth + "))");
		}
		else if(endYear == begYear)
		{
			if(endMonth >= begMonth)
			{
				e.append("(date%wateryear == " + begYear + " .and. date%month >= " +
						begMonth + " .and. date%month <= " + endMonth + ")");
			}
			else
			{
				throw wreslError(t, "Illegal date range");
			}
		}
		else
		{
			throw wreslError(t, "Illegal date range");
		}

		return e.toString();
	}

	//Method createDayMonthYearRange creates a day-month-year range logical expression
	public String createDayMonthYearRange(Token t, String beg, String end) throws ParseException
	{

		int begDay, endDay, begMonth, endMonth, begYear, endYear;
		StringBuffer e = new StringBuffer();

		begDay = new Integer(beg.substring(0, 2)).intValue();
		begMonth = new Integer(reservedList.fortranExpr(beg.substring(2, 5))).intValue();
		begYear = changeToWaterYear(new Integer(beg.substring(5, 9)).intValue(), begMonth);

		endDay = new Integer(end.substring(0, 2)).intValue();
		endMonth = new Integer(reservedList.fortranExpr(end.substring(2, 5))).intValue();
		endYear = changeToWaterYear(new Integer(end.substring(5, 9)).intValue(), endMonth);

		if(endYear > begYear)
		{
			e.append("((date%wateryear == " + begYear + " .and. " +
					"((date%month == " + begMonth + " .and. date%day >= " + begDay +
					") .or. date%month > " + begMonth + ")) .or. (date%wateryear > " + begYear +
					" .and. date%wateryear < " + endYear + ") .or. (date%wateryear == " + endYear +
					" .and. (date%month < " + endMonth + " .or. (date%month == " + endMonth +
					" .and. date%day <= " + endDay + "))))");
		}
		else if(endYear == begYear)
		{
			if(endMonth > begMonth || (endMonth == begMonth && endDay >= begDay))
			{
				e.append("(date%wateryear == " + begYear + " .and. (" +
						createDayMonthRange(beg, end) + "))");
			}
			else
			{
				throw wreslError(t, "Illegal date range");
			}
		}
		else
		{
			throw wreslError(t, "Illegal date range");
		}

		return e.toString();
	}

	/**
	 * Produces a useful error message.  Includes the line and column number.
	 *
	 * @param t       the Token at which the error occurred
	 * @param message A submessage for this error
	 * @return A new ParseException with a useful combination of information
	 * taken from the arguments supplied to this method
	 */
	final public ParseException wreslError(Token t, String message)
	{
		message = "In file " + parserInputPath.getPath() + ":\n" + message
				+ " at line " + t.beginLine + ", column " + t.beginColumn + ".";
		return new ParseException(message);
	}

	/**
	 * Study Entry point.  Scans for Wresl Study.
	 */
	final public void StudyUnit() throws ParseException
	{
		label_1:
		while(true)
		{
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case MODEL:
					ModelUnit();
					break;
				case SEQUENCE:
					SequenceUnit();
					break;
				default:
					jj_la1[0] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case SEQUENCE:
				case MODEL:
					break;
				default:
					jj_la1[1] = jj_gen;
					break label_1;
			}
		}
		jj_consume_token(0);

	}

	/**
	 * Sequence Entry point.  Scans for Wresl Sequence blocks.
	 */
	final public void SequenceUnit() throws ParseException
	{
		Token order, model;
		Token tag;
		String s;
		String neworder = "";
		String expr = ".true.";
		jj_consume_token(SEQUENCE);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				tag = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				tag = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				tag = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				tag = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[2] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		jj_consume_token(97);
		jj_consume_token(MODEL);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				model = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				model = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				model = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				model = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[3] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case CONDITION:
				jj_consume_token(CONDITION);
				expr = ConditionalExpression();
				break;
			default:
				jj_la1[4] = jj_gen;
		}
		jj_consume_token(ORDER);
		order = jj_consume_token(CONSTANT);
		jj_consume_token(98);
		seqConditionList.put(model.image.toUpperCase(), expr);
		neworder = order.image;
		if(order.image.length() < 2)
		{
			neworder = "0" + order.image;
		}
		sequenceList.put(model.image.toUpperCase(), neworder);
		s = (String) sequenceList.get(model.image.toUpperCase()); // delete later
		if(!_hideProgressDetails)
		{
			logger.println("Sequence: " + tag.image + " Model: " + model.image + " Order: " + s);
		}
		Integer i = new Integer(order.image.toUpperCase());
		if(_numberCycles <= i.intValue())
		{
			_numberCycles = i.intValue();
		}
		externalGlobalCode(s);
	}

	/**
	 * Model Entry point.  Scans for Wresl Model blocks.
	 */
	final public void ModelUnit() throws ParseException
	{
		Token model;
		String s;
		String condition;
		jj_consume_token(MODEL);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				model = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				model = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				model = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				model = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[5] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		_currentModel = model.image.toUpperCase();
		s = (String) sequenceList.get(model.image.toUpperCase());
		if(s == null)
		{
			if(true)
			{
				throw wreslError(model, "Model '" + model.image + "' not included in sequence!");
			}
		}
		_currentOrder = new Integer(s);
		_currentOrderString = s;
		if(!_hideProgressDetails)
		{
			logger.println("Model: " + model.image + " Order: " + s);
		}
		condition = (String) seqConditionList.get(_currentModel);
		try
		{
			initOutput(s, _numberCycles);
		}
		catch(Exception e)
		{
			{
				if(true)
				{
					throw new RuntimeException("Unable to initialize output: " + e.getMessage());
				}
			}
		}
		conditionGlobalCode(s, condition);
		jj_consume_token(97);
		CompilationUnit();
		jj_consume_token(98);
		//    System.out.println(_currentModel + " has " + dvarList.size() + " dvars");
		try
		{
			writeOutput();
		}
		catch(Exception e)
		{
			{
				if(true)
				{
					throw new RuntimeException(e.getMessage());
				}
			}
		}
		try
		{
			closeOutput(_numberCycles);
		}
		catch(Exception e)
		{
			e.printStackTrace(System.err);
			{
				if(true)
				{
					throw new RuntimeException(e.getMessage());
				}
			}
		}
	}

	/**
	 * Entry point.  Scans for Wresl statements or include-file directives.
	 */
	final public void CompilationUnit() throws ParseException
	{
		label_2:
		while(true)
		{
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case GOAL:
				case GOALSET:
				case DEFINE:
				case OBJECTIVE:
				case ARRAY:
					Statements();
					break;
				case INCLUDE:
					include();
					break;
				default:
					jj_la1[6] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case INCLUDE:
				case GOAL:
				case GOALSET:
				case DEFINE:
				case OBJECTIVE:
				case ARRAY:
					break;
				default:
					jj_la1[7] = jj_gen;
					break label_2;
			}
		}
		if(!_hideProgressDetails)
		{
			for(int i = 0; i < includeLevel; i++)
			{
				logger.print("    ");
			}
			logger.println("Parsed successfully");
			logger.println(""); // CB added
		}
	}

	/**
	 * Include a file.  Inserts the specified QUOTED_LITERAL file into the parse
	 * stream.
	 */
	private void include() throws ParseException
	{
		Token scope = new Token();
		scope.kind = GLOBAL;
		Token fname;
		jj_consume_token(INCLUDE);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case 99:
				jj_consume_token(99);
				switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
				{
					case LOCAL:
						scope = jj_consume_token(LOCAL);
						break;
					case GLOBAL:
						scope = jj_consume_token(GLOBAL);
						break;
					default:
						jj_la1[8] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
				jj_consume_token(100);
				break;
			default:
				jj_la1[9] = jj_gen;
		}
		fname = jj_consume_token(QUOTED_LITERAL);
		try
		{
			writeOutput();
		}
		catch(Exception e)
		{
			{
				if(true)
				{
					throw new RuntimeException(e.getMessage());
				}
			}
		}
		if(scope.kind == GLOBAL && includeLevel == 0)
		{
			_fileIsLocal = false;
		}
		if(scope.kind == LOCAL)
		{
			_fileIsLocal = true;
		}
		_currentIncludeFile = fname.image.toUpperCase();
		if(_fileIsLocal)
		{
			includeLocalList.put(_currentIncludeFile, _currentOrder);
		}
		includeFile(token);
		if(includeLevel == 0)
		{
			_fileIsLocal = false;
		}
	}

	/**
	 * Wresl statements.  Definitions, goals, or goal sets.
	 */
	final public void Statements() throws ParseException
	{
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case DEFINE:
				DefineStatement();
				break;
			case GOAL:
				GoalStatement();
				break;
			case GOALSET:
				GoalsetStatement();
				break;
			case OBJECTIVE:
				ObjectiveStatement();
				break;
			case ARRAY:
				ArrayStatement();
				break;
			default:
				jj_la1[10] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
	}

	/**
	 *
	 */
	final public void ObjectiveStatement() throws ParseException
	{
		Token id;
		jj_consume_token(OBJECTIVE);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				id = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				id = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				id = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				id = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[11] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		jj_consume_token(SINGLE_EQ);
		jj_consume_token(97);
		label_3:
		while(true)
		{
			ObjectiveListTerm();
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case 99:
					break;
				default:
					jj_la1[12] = jj_gen;
					break label_3;
			}
		}
		jj_consume_token(98);
	}

	/**
	 * Definition statement.
	 */
	final public void DefineStatement() throws ParseException
	{
		Token id;
		Integer gp_level = new Integer(1);
		Token scope = new Token();
		scope.kind = GLOBAL;
		jj_consume_token(DEFINE);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case 99:
				jj_consume_token(99);
				switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
				{
					case LOCAL:
						scope = jj_consume_token(LOCAL);
						break;
					case GLOBAL:
						scope = jj_consume_token(GLOBAL);
						break;
					default:
						jj_la1[13] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
				jj_consume_token(100);
				break;
			default:
				jj_la1[14] = jj_gen;
		}
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				id = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				id = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				id = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				id = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[15] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		//CB dvars -- have max of 16 and are checked elsewhere
		if(id.image.length() > 32)
		{
			if(true)
			{
				throw wreslError(id,
						"Identifier '" + id.image + "' exceeds max of 32 characters");
			}
		}
		if(scope.kind == LOCAL || _fileIsLocal)
		{
			scope.kind = LOCAL;
			_controlDefines = localDefines;
		}
		else
		{
			_controlDefines = globalDefines;
		}
		jj_consume_token(97);
		DefinitionSpec(id, scope);
		jj_consume_token(98);
	}

	/**
	 * The type of definition:  decision variable, alias, timeseries lookup,
	 * external procedure, or value definition.
	 */
	final public void DefinitionSpec(Token id, Token scope) throws ParseException
	{
		if(reservedList.isIn(id.image))
		{
			throw wreslError(id,
					"Identifier '" + id.image + "' is predefined and may not be reused");
		}
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case STD:
			case LOWER:
			case UPPER:
			case INTEGER:
				DvarDef(id, scope);
				if(id.image.length() > 2)
				{
					if(id.image.substring(0, 3).equalsIgnoreCase("OBJ"))
					{
						{
							if(true)
							{
								throw wreslError(id,
										"Decision variable names can not begin with letter sequence 'OBJ'");
							}
						}
					}
				}
				break;
			case ALIAS:
				AliasDef(id, scope);
				if(id.image.length() > 2)
				{
					if(id.image.substring(0, 3).equalsIgnoreCase("OBJ"))
					{
						{
							if(true)
							{
								throw wreslError(id,
										"Decision variable names can not begin with letter sequence 'OBJ'");
							}
						}
					}
				}
				break;
			case TIMESERIES:
				LookupTimeseriesDef(id, scope);
				break;
			case EXTERNAL:
				ExternalProc(id);
				break;
			case VALUE:
			case SELECT:
			case SUM:
			case CASE:
				ValueDef(id, scope);
				break;
			default:
				jj_la1[16] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
	}

	/**
	 * Declares the name of an external object file to link in to the model.
	 */
	final public void ExternalProc(Token id) throws ParseException
	{
		Token type;
		type = null;
		String name = id.image.toUpperCase();
		jj_consume_token(EXTERNAL);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case DLL:
				type = jj_consume_token(DLL);
				break;
			default:
				jj_la1[19] = jj_gen;
				label_4:
				while(true)
				{
					switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
					{
						case DAYMONTH:
						case MONTHYEAR:
						case DAYMONTHYEAR:
						case IDENTIFIER:
							break;
						default:
							jj_la1[17] = jj_gen;
							break label_4;
					}
					switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
					{
						case IDENTIFIER:
							type = jj_consume_token(IDENTIFIER);
							break;
						case DAYMONTH:
							type = jj_consume_token(DAYMONTH);
							break;
						case MONTHYEAR:
							type = jj_consume_token(MONTHYEAR);
							break;
						case DAYMONTHYEAR:
							type = jj_consume_token(DAYMONTHYEAR);
							break;
						default:
							jj_la1[18] = jj_gen;
							jj_consume_token(-1);
							throw new ParseException();
					}
				}
		}
		if(externalList.containsKey(name))
		{
			if(true)
			{
				throw wreslError(id, "Redefining External Procedure '" + name + "'");
			}
		}
		else
		{
			externalList.put(name, _currentOrder);
			//CB	_controlDefines.println(name);
			//CB	_controlDefines.println("-1               ExternalProc");
			_writer.println(_controlDefines, name);  //CB
			_writer.println(_controlDefines, "-1               ExternalProc");  //CB

		}

		if(!type.image.toLowerCase().endsWith(".dll"))
		{
			if(!new File(rootDirectory + "\\" + "external" + "\\", name + ".obj").exists())
			{
				if(true)
				{
					throw wreslError(id, "External Procedure '" + name + ".obj' does not exist in external directory.");
				}
			}
			globalExternals.print(rootDirectory + "\\" + "external" + "\\");
			globalExternals.println(name + ".obj");
			if(type.image.equalsIgnoreCase("dll"))
			{
				if(!new File(rootDirectory + "\\" + "external" + "\\", name + ".lib").exists())
				{
					if(true)
					{
						throw wreslError(id,
								"External Procedure '" + name + ".lib' does not exist in external directory.");
					}
				}
				globalExternalsLib.print("-lib " + rootDirectory + "\\" + "external" + "\\");
				globalExternalsLib.println(name + ".lib");
			}
		}
		else
		{
			if(dllList.newItem(type.image.toUpperCase()))
			{
				if(!new File(rootDirectory + "\\" + "external" + "\\", type.image).exists())
				{
					if(true)
					{
						throw wreslError(id,
								"External Procedure '" + type.image + "' does not exist in external directory.");
					}
				}
				globalExternalsLib.println("-implib " + rootDirectory + "\\external\\" + type.image);
			}
			globalExternalsLib.println("-import " + name);
		}
	}

	/**
	 * Definition of a state variable.
	 */
	final public void ValueDef(Token id, Token scope) throws ParseException
	{
		int caseNum = 1;
		UniqueList caseList = new UniqueList(4, 4);   // stores case (condition) names
		String name = id.image.toUpperCase();

		condIsAlways = false;
		// NOTICE: this will be executed before it determines that this is indeed a value def
		if(scope.kind == LOCAL)
		{
			if(!valueDefLocalList.newItem(name))
			{
				throw wreslError(id, "Redefining '" + name + "' within Model");
			}
			if(valueDefList.getIdCode(name) != null)
			{
				throw wreslError(id, "Redefining '" + name + "'");   //CB is id code used for anything but list?
			}
			//CB    _controlDefines.println(make32( name));
			_writer.println(_controlDefines, make32(name));
		}
		else
		{
			if(!valueDefList.newItem(name))
			{
				throw wreslError(id, "Redefining '" + name + "'");
			}
			//CB        _controlDefines.println(make32(name).append(valueDefList.getIdCode(name)));
			_writer.println(_controlDefines, make32(name).append(valueDefList.getIdCode(name)));
		}
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case CASE:
				label_5:
				while(true)
				{
					CaseStatement(caseNum++, caseList, _controlDefines);
					ValueExpression();
					jj_consume_token(98);
					switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
					{
						case CASE:
							break;
						default:
							jj_la1[20] = jj_gen;
							break label_5;
					}
				}
				break;
			case VALUE:
			case SELECT:
			case SUM:
				soleCondition(_controlDefines);
				ValueExpression();
				break;
			default:
				jj_la1[21] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		noMoreCases(_controlDefines);
		if(caseNum > 1 && !condIsAlways)
		{
			if(true)
			{
				throw wreslError(id, "Final condition must be 'always' for '" + name + "'");
			}
		}
	}

	/**
	 * A constant state variable definition.
	 */
	final public void ValueExpression() throws ParseException
	{
		StringBuffer expr = new StringBuffer();
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case VALUE:
				jj_consume_token(VALUE);
				NonDvarExpression(expr);
				break;
			case SELECT:
				LookupRDBDef(expr);
				break;
			case SUM:
				SumExpression(expr);
				break;
			default:
				jj_la1[22] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		//CB        _controlDefines.println(expr.toString());  // fortran expression
		_writer.println(_controlDefines, expr.toString());  //CB

	}

	/**
	 * A state variable summation definition.
	 */
	final public void SumExpression(StringBuffer expr) throws ParseException
	{
		Token index;
		StringBuffer beg = new StringBuffer();
		StringBuffer end = new StringBuffer();
		StringBuffer step = new StringBuffer();
		jj_consume_token(SUM);
		jj_consume_token(101);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				index = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				index = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				index = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				index = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[23] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		jj_consume_token(SINGLE_EQ);
		NonDvarExpression(beg);
		jj_consume_token(102);
		NonDvarExpression(end);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case 102:
				jj_consume_token(102);
				NonDvarExpression(step);
				break;
			default:
				jj_la1[24] = jj_gen;
		}
		jj_consume_token(103);
		NonDvarExpression(expr);
		if(step.toString().compareTo("") == 0)
		{           // blank string
			//CB        	_controlDefines.println("$"+index.image+"="+beg.toString()+","+end.toString());
			_writer.println(_controlDefines, "$" + index.image + "=" + beg.toString() + "," + end.toString());  //CB
		}
		else
		{
			//CB        	_controlDefines.println("$"+index.image+"="+beg.toString()+","+end.toString()+","+step.toString());

			_writer.println(_controlDefines,
					"$" + index.image + "=" + beg.toString() + "," + end.toString() + "," + step.toString());  //CB
		}
	}

	/**
	 * A database lookup definition.  Consists of several forms.
	 */
	final public void LookupRDBDef(StringBuffer expr) throws ParseException
	{
		Token table, result;
		StringBuffer givenColumn = new StringBuffer();
		StringBuffer givenExpr = new StringBuffer();
		StringBuffer whereColumns = new StringBuffer();
		StringBuffer valueColumns = new StringBuffer();
		int useMethod = 0;
		jj_consume_token(SELECT);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				result = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				result = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				result = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				result = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[25] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		jj_consume_token(FROM);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				table = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				table = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				table = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				table = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[26] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case GIVEN:
				jj_consume_token(GIVEN);
				ItemValuePair(givenColumn, givenExpr);
				jj_consume_token(USE);
				switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
				{
					case MINIMUM:
						jj_consume_token(MINIMUM);
						break;
					case LINEAR:
						jj_consume_token(LINEAR);
						break;
					case MEAN:
						jj_consume_token(MEAN);
						break;
					case MAXIMUM:
						jj_consume_token(MAXIMUM);
						break;
					default:
						jj_la1[27] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
				if(token.kind == MINIMUM)
				{
					useMethod = 1;
				}
				else if(token.kind == LINEAR)
				{
					useMethod = 2;
				}
				else if(token.kind == MEAN)
				{
					useMethod = 3;
				}
				else /* MAX */
				{
					useMethod = 4;
				}
				break;
			default:
				jj_la1[28] = jj_gen;
		}
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case WHERE:
				jj_consume_token(WHERE);
				MultipleOA(whereColumns, valueColumns);
				break;
			default:
				jj_la1[29] = jj_gen;
		}
		if(useMethod == 0 && whereColumns.length() == 0)
		{
			{
				if(true)
				{
					throw wreslError(table, "Must specify GIVEN and/or WHERE tags");
				}
			}
		}
		else if(useMethod == 0)
		{
			// they gave us only Select
			expr.append("tableBasic( '" + table.image + "','" + result.image + "',"
					+ "wc=" + whereColumns + ",wv=" + valueColumns + ")");
		}
		else if(whereColumns.length() == 0)
		{
			// they gave us only Given/Use
			expr.append("tableLookup( '" + table.image + "','" + result.image + "',"
					+ "gv=" + givenExpr + ",gc=" + givenColumn + ",um=" + useMethod + ")");
		}
		else
		{
			// they gave us both
			expr.append("tableComplex( '" + table.image + "','" + result.image + "',"
					+ "gv=" + givenExpr + ",gc=" + givenColumn + ",um=" + useMethod +
					",wc=" + whereColumns + ",wv=" + valueColumns + ")");
		}
	}

	/**
	 * A collection of ItemValuePairs, collated.
	 */
	final public void MultipleOA(StringBuffer items, StringBuffer values) throws ParseException
	{
		StringBuffer oa_item, oa_value;
		int comma;
		ItemValuePair(oa_item = new StringBuffer(), oa_value = new StringBuffer());
		items.append(oa_item);
		values.append(oa_value);
		label_6:
		while(true)
		{
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case 102:
					break;
				default:
					jj_la1[30] = jj_gen;
					break label_6;
			}
			jj_consume_token(102);
			ItemValuePair(oa_item = new StringBuffer(), oa_value = new StringBuffer());
			items.append("," + oa_item);
			values.append("," + oa_value);
		}
		items.insert(0, "(/");
		values.insert(0, "(/");
		items.append("/)");
		values.append("/)");
	}

	/**
	 * An item name and an optional value identifier.  Expressions of the form
	 * <i>item = value</i> or <i>item</i> where the value is assumed to be
	 * an identifier having the same name as <i>item</i>.
	 */
	final public void ItemValuePair(StringBuffer expr1, StringBuffer expr2) throws ParseException
	{
		StringBuffer given = new StringBuffer();
		Token fieldname;
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				fieldname = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				fieldname = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				fieldname = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				fieldname = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[31] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case SINGLE_EQ:
				jj_consume_token(SINGLE_EQ);
				NonDvarExpression(given);
				break;
			default:
				jj_la1[32] = jj_gen;
		}
		if(given.length() == 0)
		{
			if(valueDefList.getIndexOf(fieldname.image) >= 0)
			{
				given.append(fieldname);
			}
			else
			{
				if(reservedList.isIn(fieldname.image))
				{
					given.append("real(" +
							reservedList.fortranExpr(fieldname.image) + ")");
				}
				else
				{
					{
						if(true)
						{
							throw wreslError(fieldname, "Must use '=' or define '"
									+ fieldname.image + "' as a value definition.");
						}
					}
				}
			}
		}
		else
		{
			given.insert(0, "real(").append(")");
		}
		expr1.append("'" + make32(fieldname.image) + "'");
		expr2.append(given);
	}

	/**
	 * Definition of a value to be read in from a timeseries database.
	 */
	final public void LookupTimeseriesDef(Token id, Token scope) throws ParseException
	{
		Token kind, units, bpart;
		Token convert = new Token();
		convert.image = "UNKNOWN";
		bpart = new Token();
		bpart.image = "'" + id + "'";
		Timeseries ts;
		String name = id.image.toUpperCase();
		jj_consume_token(TIMESERIES);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case QUOTED_LITERAL:
				bpart = jj_consume_token(QUOTED_LITERAL);
				break;
			default:
				jj_la1[33] = jj_gen;
		}
		jj_consume_token(KIND);
		kind = jj_consume_token(QUOTED_LITERAL);
		jj_consume_token(UNITS);
		units = jj_consume_token(QUOTED_LITERAL);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case CONVERT:
				jj_consume_token(CONVERT);
				convert = jj_consume_token(QUOTED_LITERAL);
				break;
			default:
				jj_la1[34] = jj_gen;
		}
		ts = new Timeseries(id.image.toUpperCase(), bpart.image, kind.image, units.image, convert.image);
		tsParamList.put(id.image.toUpperCase(), ts);

		if(scope.kind == LOCAL)
		{
			if(!tsDefLocalList.newItem(name))
			{
				if(true)
				{
					throw wreslError(id, "Redefining '" + name + "' within Model");
				}
			}
			//    	if (tsDefList.getIdCode(name)!=null) throw wreslError(id,"Redefining '" + name + "'");
			// fix scoping ts
			if(_hideWarnings)
			{ // CB added to allow user to turn off warning messages
				tsDefList.newItem(name);
			}
			else
			{
				if(!tsDefList.newItem(name))
				{
					logger.println("Warning! Local TS '" + name
							+ "' value will be same as Global.");
				}
			}
			globalDssInit.print("call dss_ts_init(  " + (tsDefList.getIndexOf(name) + 1) + ","
					+ bpart.image + "," + kind.image + "," + units.image);
		}
		else
		{
			if(!tsDefList.newItem(name))
			{
				if(true)
				{
					throw wreslError(id, "Redefining '" + name + "'");
				}
			}
			globalDssInit.print("call dss_ts_init(  "
					+ (tsDefList.getIndexOf(name) + 1) + "," + bpart.image + "," + kind.image + ","
					+ units.image);
		}
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case DESC:
				jj_consume_token(DESC);
				jj_consume_token(QUOTED_LITERAL);
				globalDssInit.print(", desc=" + token.image);
				break;
			default:
				jj_la1[35] = jj_gen;
		}
		globalDssInit.println(")");
	}

	/**
	 * Definition of an LP decision variable.
	 */
	final public void DvarDef(Token id, Token scope) throws ParseException
	{
		DvarBounder dvarDef = new DvarBounder(id.image);
		String kind = "'LP DVAR'";
		String units = "'UNKNOWN'";
		String name = id.image.toUpperCase();

		if(id.image.length() > 16)
		{
			throw wreslError(id,
					"Identifier '" + id.image + "' exceeds max of 16 characters");
		}
		if(name.indexOf("SURPL") == 0 || name.indexOf("SLACK") == 0)
		{
			throw wreslError(id, "SURPL and SLACK are reserved strings! Rename '" + name + "'");
		}
		if(scope.kind == LOCAL)
		{
			//CB    if (!dvarLocalList.newItem(name)) throw wreslError(id, "Redefining '" + name + "' within Model");
			if(!dvarLocalList.newItem(name))  //CB altered
			{
				throw wreslError(id, "Redefining local variable '" + name + "' within Model");
			}
			// fix scoping dvar bounds
			if(_hideWarnings)
			{ // CB added to allow user to turn off warning messages
				dvarList.newItem(name); // warnings off
			}
			else
			{
				if(!dvarList.newItem(name))
				{
					logger.println("Warning! Local Dvar '" + name
							+ "' bounds will be same as Global.");
				}
			}
		}
		else
		{
			if(!dvarList.newItem(name))
			{
				throw wreslError(id, "Redefining global variable '" + name + "'");
			}
			//wip     if (!dvarLocalList.newItem(name)) throw wreslError(id, "Redefining global variable '" + name + "' same as local variable within Model"); //CB added
			//wip     if (_currentOrder > 1) throw wreslError(id, "Defining global variable '" + name + "' in other than the first sequence"); //CB added
		}
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case INTEGER:
				jj_consume_token(INTEGER);
				dvarDef.setInteger();
				switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
				{
					case CONSTANT:
						jj_consume_token(CONSTANT);
						dvarDef.setIntegerPriority(token.image);
						break;
					default:
						jj_la1[36] = jj_gen;
				}
				break;
			default:
				jj_la1[37] = jj_gen;
		}
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case LOWER:
			case UPPER:
				UpperLowerSpec(dvarDef);
				break;
			case STD:
				jj_consume_token(STD);
				break;
			default:
				jj_la1[38] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		jj_consume_token(KIND);
		jj_consume_token(QUOTED_LITERAL);
		kind = token.image;
		jj_consume_token(UNITS);
		jj_consume_token(QUOTED_LITERAL);
		units = token.image;
		dvarDef.output(goals);
		globalDssInit.print("call dss_dvar_init( " +
				(dvarList.getIndexOf(name) + 1)
				+ ",'" + name + "'," + kind + "," + units);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case DESC:
				jj_consume_token(DESC);
				jj_consume_token(QUOTED_LITERAL);
				globalDssInit.print(", desc=" + token.image);
				break;
			default:
				jj_la1[39] = jj_gen;
		}
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case HEADER:
				jj_consume_token(HEADER);
				jj_consume_token(QUOTED_LITERAL);
				globalDssInit.print(",&\r\n   header=" + token.image);
				break;
			default:
				jj_la1[40] = jj_gen;
		}
		globalDssInit.println(")");
	}

	/**
	 * The upper or lower bound for the specified decision variable.
	 *
	 * @param dv The specific decision variable bounding instance.
	 */
	final public void UpperLowerSpec(DvarBounder dv) throws ParseException
	{
		label_7:
		while(true)
		{
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case UPPER:
					UpperSpec(dv);
					break;
				case LOWER:
					LowerSpec(dv);
					break;
				default:
					jj_la1[41] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case LOWER:
				case UPPER:
					break;
				default:
					jj_la1[42] = jj_gen;
					break label_7;
			}
		}
	}

	/**
	 * An upper bound to be applied to this decision variable.
	 */
	final public void UpperSpec(DvarBounder dv) throws ParseException
	{
		jj_consume_token(UPPER);
		PossiblyUnboundedExpr();
		if(token.kind != UNBOUNDED)
		{
			dv.setUpper(token.image);
		}
		else
		{
			dv.setUpper();
		}
	}

	/**
	 * A lower bound to be applied to this decision variable.
	 */
	final public void LowerSpec(DvarBounder dv) throws ParseException
	{
		jj_consume_token(LOWER);
		PossiblyUnboundedExpr();
		if(token.kind != UNBOUNDED)
		{
			dv.setLower(token.image);
		}
		else
		{
			dv.setLower();
		}
	}

	/**
	 * Sets the current token to either the UNBOUNDED token or to
	 * an expression of non-decision variable terms.
	 */
	final public void PossiblyUnboundedExpr() throws ParseException
	{
		StringBuffer e = new StringBuffer();
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case UNBOUNDED:
				jj_consume_token(UNBOUNDED);
				break;
			case SUBTRACT:
			case ABS:
			case INT:
			case NINT:
			case REAL:
			case MOD:
			case EXP:
			case LOG:
			case LOG10:
			case SQRT:
			case MAX:
			case MIN:
			case POW:
			case DAYMONTH:
			case MONTHYEAR:
			case DAYMONTHYEAR:
			case CONSTANT:
			case IDENTIFIER:
			case 101:
				NonDvarExpression(e);
				token.image = e.toString();
				break;
			default:
				jj_la1[43] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
	}

	/**
	 * An Alias definition.  Defines a dummy goal to accomplish the alias.
	 *
	 * @param id The token containing the name for the alias.
	 */
	final public void AliasDef(Token id, Token scope) throws ParseException
	{
		LPExpression aliasedExpr;
		DvarBounder dvarDef = new DvarBounder(id.image);
		dvarDef.setLower();  // unbounded lower limit
		Token units;
		Token kind = new Token();
		kind.image = "'ALIAS'";
		String name = id.image.toUpperCase();
		String aliasTag = name + "_alias";
		jj_consume_token(ALIAS);
		LinearExpression(aliasedExpr = new LPExpression());
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case KIND:
				jj_consume_token(KIND);
				kind = jj_consume_token(QUOTED_LITERAL);
				break;
			default:
				jj_la1[44] = jj_gen;
		}
		jj_consume_token(UNITS);
		units = jj_consume_token(QUOTED_LITERAL);
		if(id.image.length() > 16)
		{
			if(true)
			{
				throw wreslError(id,
						"Identifier '" + id.image + "' exceeds max of 16 characters");
			}
		}
		if(scope.kind == LOCAL)
		{
			if(!dvarLocalList.newItem(name))
			{
				if(true)
				{
					throw wreslError(id, "Redefining '" + name + "' within Model");
				}
			}
			// if (dvarList.getIdCode(name)!=null) throw wreslError(id,"Redefining '" + name + "'");
			if(_hideWarnings)
			{ // CB added to allow user to turn off warning messages
				dvarList.newItem(name); // warnings off
			}
			else
			{
				if(!dvarList.newItem(name))
				{
					logger.println("Warning! Local Alias '" + name
							+ "' bounds will be same as Global.");
				}
			}
			aliasTag = _currentOrderString.concat(aliasTag);
		}
		else
		{
			if(!dvarList.newItem(name))
			{
				if(true)
				{
					throw wreslError(id, "Redefining '" + name + "'");
				}
			}
			aliasTag = "00" + aliasTag;
		}

		dvarDef.output(goals);
		LPExpression theAlias = new LPExpression(
				new LPTerm(name, "1"));   // add the new alias dvar to the LP Expression
		theAlias.merge(aliasedExpr);
		Penalizer p = new Penalizer();
		goals.println(make32(aliasTag)); // goal name
		soleCondition(goals);               // always condition
		theAlias.output(goals);             // lhs and rhs printout
		goals.println(p.asString());        // lhs>rhs: constrain
		goals.println(p.asString());        // lhs<rhs: constrain
		noMoreCases(goals);                 // 99999   end of cases
		globalDssInit.println("call dss_dvar_init( " + (dvarList.getIndexOf(name) + 1) +
				",'" + name + "'," + kind.image + "," + units.image + ")");
	}

	/**
	 * Introduction of a goal set.  It contains one or more goals.
	 */
	final public void GoalsetStatement() throws ParseException
	{
		jj_consume_token(GOALSET);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[45] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		jj_consume_token(97);
		label_8:
		while(true)
		{
			GoalStatement();
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case GOAL:
					break;
				default:
					jj_la1[46] = jj_gen;
					break label_8;
			}
		}
		jj_consume_token(98);
	}

	/**
	 * A goal statement, or penalized LP constraint.
	 */
	final public void GoalStatement() throws ParseException
	{
		LPExpression lhs;
		Integer gp_level = new Integer(0);
		Token tag;
		Token scope = new Token();
		scope.kind = GLOBAL;
		jj_consume_token(GOAL);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case 99:
				jj_consume_token(99);
				switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
				{
					case LOCAL:
						scope = jj_consume_token(LOCAL);
						break;
					case GLOBAL:
						scope = jj_consume_token(GLOBAL);
						break;
					default:
						jj_la1[47] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
				jj_consume_token(100);
				break;
			default:
				jj_la1[48] = jj_gen;
		}
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				tag = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				tag = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				tag = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				tag = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[49] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		if(tag.image.length() > 29)
		{
			if(true)
			{
				throw wreslError(tag,
						"Goal name '" + tag.image + "' exceeds max of 29 characters");
			}
		}
		if(scope.kind == LOCAL || _fileIsLocal)
		{
			tag.image = _currentOrderString.concat(tag.image);
		}
		else
		{
			tag.image = "00" + tag.image;
		}

		if(!tagList.newItem(tag.image) || goalLocalList.containsKey(tag.image))
		{
			{
				if(true)
				{
					throw wreslError(tag, "Redefining '" + tag.image.substring(1) + "'");
				}
			}
		}
		goals.println(make32(tag.image));
		if(scope.kind == LOCAL || _fileIsLocal)
		{
			goalLocalList.put(tag.image, _currentOrder);
		}
		jj_consume_token(97);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case LHS:
				jj_consume_token(LHS);
				LinearExpression(lhs = new LPExpression());
				GoalBody(lhs);
				break;
			case SUBTRACT:
			case ABS:
			case INT:
			case NINT:
			case REAL:
			case MOD:
			case EXP:
			case LOG:
			case LOG10:
			case SQRT:
			case MAX:
			case MIN:
			case POW:
			case DAYMONTH:
			case MONTHYEAR:
			case DAYMONTHYEAR:
			case CONSTANT:
			case IDENTIFIER:
			case 101:
				InlineGoal();
				break;
			default:
				jj_la1[50] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		jj_consume_token(98);
		noMoreCases(goals);
	}

	/**
	 * A goal programming priority level.  Default is 0 if omitted.
	 *
	 * @return The desired priority level
	 */
	final public Integer GPLevelSpec() throws ParseException
	{
		Token gp;
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case 99:
				jj_consume_token(99);
				gp = jj_consume_token(CONSTANT);
				jj_consume_token(100);
				int level = 0;
				try
				{
					level = Integer.parseInt(gp.image);
				}
				catch(NumberFormatException ee)
				{
					{
						if(true)
						{
							throw wreslError(gp, "Must be an integer");
						}
					}
				}
				if(level < 1 || level > 9)
				{
					if(true)
					{
						throw wreslError(gp, "Priority Level must be between 1 and 9");
					}
				}
			{
				if(true)
				{
					return new Integer(level);
				}
			}
			break;
			default:
				jj_la1[51] = jj_gen;
		}
		{
			if(true)
			{
				return new Integer(0);
			}
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Shorthand statement for an unpenalized goal.
	 */
	final public void InlineGoal() throws ParseException
	{
		LPExpression lhs = new LPExpression();
		LPExpression rhs = new LPExpression();
		Token comp;
		LinearExpression(lhs);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case GT:
				comp = jj_consume_token(GT);
				break;
			case LT:
				comp = jj_consume_token(LT);
				break;
			case SINGLE_EQ:
				comp = jj_consume_token(SINGLE_EQ);
				break;
			default:
				jj_la1[52] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		LinearExpression(rhs);
		lhs.merge(rhs);
		Penalizer greater = new Penalizer();
		Penalizer less = new Penalizer();
		if(comp.kind == GT)
		{
			greater.newPenalty("0.");
		}
		if(comp.kind == LT)
		{
			less.newPenalty("0.");
		}
		soleCondition(goals);               // always condition
		lhs.output(goals);                  // both lhs and rhs printout
		goals.println(greater.asString());        // lhs>rhs: constrain
		goals.println(less.asString());        // lhs<rhs: constrain

	}

	/**
	 * Standard goal statement body.  Consists of either a set of cases
	 * or a sole condition.
	 *
	 * @param lhs The expression specified under the LHS token
	 */
	final public void GoalBody(LPExpression lhs) throws ParseException
	{
		int caseNumber = 1;
		UniqueList caseList = new UniqueList(4, 4);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case CASE:
				label_9:
				while(true)
				{
					CaseStatement(caseNumber++, caseList, goals);
					LRSpecification(lhs);
					jj_consume_token(98);
					switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
					{
						case CASE:
							break;
						default:
							jj_la1[53] = jj_gen;
							break label_9;
					}
				}
				break;
			case RHS:
				soleCondition(goals);
				LRSpecification(lhs);
				break;
			default:
				jj_la1[54] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
	}

	/**
	 * A RHS expression, optionally with penalties.
	 *
	 * @param lhs The expression specified under the LHS token
	 */
	final public void LRSpecification(LPExpression lhs) throws ParseException
	{
		LPExpression rhs = new LPExpression();
		rhs.keepLeft();
		Penalizer grtrthan, lessthan;
		jj_consume_token(RHS);
		LinearExpression(rhs);
		LPExpression constraint = new LPExpression(lhs);  // resultant one (final output)
		constraint.merge(rhs);
		constraint.output(goals);
		PenaltySpec(lessthan = new Penalizer(), grtrthan = new Penalizer());
		goals.println(grtrthan.asString());       // their lhs > rhs spec
		goals.println(lessthan.asString());       // their lhs < rhs spec

	}

	/**
	 * Specification of penalties to be applied to this constraint.
	 */
	final public void PenaltySpec(Penalizer lessthan, Penalizer grtrthan) throws ParseException
	{
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case LESSTHAN:
			case GRTRTHAN:
				switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
				{
					case GRTRTHAN:
						jj_consume_token(GRTRTHAN);
						PenaltyExpression(grtrthan);
						switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
						{
							case LESSTHAN:
								jj_consume_token(LESSTHAN);
								PenaltyExpression(lessthan);
								break;
							default:
								jj_la1[55] = jj_gen;
						}
						break;
					case LESSTHAN:
						jj_consume_token(LESSTHAN);
						PenaltyExpression(lessthan);
						switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
						{
							case GRTRTHAN:
								jj_consume_token(GRTRTHAN);
								PenaltyExpression(grtrthan);
								break;
							default:
								jj_la1[56] = jj_gen;
						}
						break;
					default:
						jj_la1[57] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
				break;
			default:
				jj_la1[58] = jj_gen;
		}
	}

	/**
	 * An expression that will be applied to a particular penalty.
	 */
	final public void PenaltyExpression(Penalizer p) throws ParseException
	{
		StringBuffer e = new StringBuffer();
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case PENALTY:
				jj_consume_token(PENALTY);
				NonDvarExpression(e);
				p.newPenalty(e.toString());
				break;
			case CONSTRAIN:
				jj_consume_token(CONSTRAIN);
				break;
			default:
				jj_la1[59] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
	}

	/**
	 * One particular case.
	 *
	 * @param number   The case number, assigned by the calling method.
	 * @param caseList The list of condition names in this block of cases
	 * @param s        Destination for the value of this case
	 */
	final public void CaseStatement(int number, UniqueList caseList, java.io.PrintWriter s) throws ParseException
	{
		Token id;
		String expr;
		jj_consume_token(CASE);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				id = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				id = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				id = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				id = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[60] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		if(id.image.length() > 32)
		{
			if(true)
			{
				throw wreslError(id,
						"Case name '" + id.image + "' exceeds max of 32 characters");
			}
		}
		if(!caseList.newItem(id.image))
		{
			if(true)
			{
				throw wreslError(id,
						"Redefining case '" + id.image + "'");
			}
		}
		jj_consume_token(97);
		jj_consume_token(CONDITION);
		expr = ConditionalExpression();
		condIsAlways = expr.equalsIgnoreCase("ALWAYS");
		s.println(number + "                " + id.image);
		s.println(expr.toLowerCase());           // thing for the Fortran IF statement

	}

	/**
	 * A combination of one or more logically-valued expressions.
	 * Optionally, the ALWAYS token which is equivalent to logical TRUE.
	 */
	final public String ConditionalExpression() throws ParseException
	{
		StringBuffer e = new StringBuffer();
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case ALWAYS:
				jj_consume_token(ALWAYS);
			{
				if(true)
				{
					return token.image;
				}
			}
			break;
			case SUBTRACT:
			case NOT:
			case ABS:
			case INT:
			case NINT:
			case REAL:
			case MOD:
			case EXP:
			case LOG:
			case LOG10:
			case SQRT:
			case MAX:
			case MIN:
			case POW:
			case RANGE:
			case DAYMONTH:
			case MONTHYEAR:
			case DAYMONTHYEAR:
			case CONSTANT:
			case IDENTIFIER:
			case 101:
				LogicalExpression(e);
				label_10:
				while(true)
				{
					switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
					{
						case AND:
						case OR:
							break;
						default:
							jj_la1[61] = jj_gen;
							break label_10;
					}
					switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
					{
						case AND:
							jj_consume_token(AND);
							break;
						case OR:
							jj_consume_token(OR);
							break;
						default:
							jj_la1[62] = jj_gen;
							jj_consume_token(-1);
							throw new ParseException();
					}
					e.append(token.image);
					LogicalExpression(e);
				}
			{
				if(true)
				{
					return e.toString();
				}
			}
			break;
			default:
				jj_la1[63] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Two numeric expressions joined by a logical operator or
	 * a range specification for a given parameter from which a logical
	 * expression can be constructed.
	 */
	final public void LogicalExpression(StringBuffer e) throws ParseException
	{
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case NOT:
				jj_consume_token(NOT);
				e.append(token.image);
				break;
			default:
				jj_la1[64] = jj_gen;
		}
		if(jj_2_1(2))
		{
			RangeExpression(e);
		}
		else
		{
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case SUBTRACT:
				case ABS:
				case INT:
				case NINT:
				case REAL:
				case MOD:
				case EXP:
				case LOG:
				case LOG10:
				case SQRT:
				case MAX:
				case MIN:
				case POW:
				case DAYMONTH:
				case MONTHYEAR:
				case DAYMONTHYEAR:
				case CONSTANT:
				case IDENTIFIER:
				case 101:
					NonDvarExpression(e);
					switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
					{
						case LT:
							jj_consume_token(LT);
							break;
						case GT:
							jj_consume_token(GT);
							break;
						case GE:
							jj_consume_token(GE);
							break;
						case LE:
							jj_consume_token(LE);
							break;
						case EQ:
							jj_consume_token(EQ);
							break;
						case NE:
							jj_consume_token(NE);
							break;
						default:
							jj_la1[65] = jj_gen;
							jj_consume_token(-1);
							throw new ParseException();
					}
					e.append(token.image);
					NonDvarExpression(e);
					break;
				default:
					jj_la1[66] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
		}
	}

	/**
	 * A range logical expression.
	 */
	final public void RangeExpression(StringBuffer e) throws ParseException
	{
		jj_consume_token(RANGE);
		jj_consume_token(101);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case DATE:
				DateRangeExpression(e);
				break;
			case SUBTRACT:
			case ABS:
			case INT:
			case NINT:
			case REAL:
			case MOD:
			case EXP:
			case LOG:
			case LOG10:
			case SQRT:
			case MAX:
			case MIN:
			case POW:
			case DAYMONTH:
			case MONTHYEAR:
			case DAYMONTHYEAR:
			case CONSTANT:
			case IDENTIFIER:
			case 101:
				NonDvarRangeExpression(e);
				break;
			default:
				jj_la1[67] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		jj_consume_token(103);
	}

	/**
	 * A range logical expression where the variable and upper and
	 * lower bounds are made up of NonDvarExpressions
	 */
	final public void NonDvarRangeExpression(StringBuffer e) throws ParseException
	{
		Token varToken = new Token();
		StringBuffer var, beg, end;
		boolean monthrange = false;
		boolean dayrange = false;
		NonDvarExpression(var = new StringBuffer());
		varToken = token;
		if(token.image.equalsIgnoreCase("month"))
		{
			monthrange = true;
		}
		else if(token.image.equalsIgnoreCase("day"))
		{
			dayrange = true;
		}
		jj_consume_token(102);
		NonDvarExpression(beg = new StringBuffer());
		jj_consume_token(102);
		NonDvarExpression(end = new StringBuffer());
		if(monthrange)
		{
			e.append(createMonthRange(varToken, beg.toString(), end.toString()));
		}
		else if(dayrange)
		{
			e.append(createDayRange(varToken, beg.toString(), end.toString()));
		}
		else
		{
			e.append(createOrdinaryRange(var.toString(), beg.toString(), end.toString()));
		}
	}

	/**
	 * A range logical expression where the parameter is "date" and
	 * the lower and upper bounds are defined in one of three formats:
	 * "01APR1976","01APR", or "APR1976"
	 */
	final public void DateRangeExpression(StringBuffer e) throws ParseException
	{
		jj_consume_token(DATE);
		jj_consume_token(102);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case DAYMONTHYEAR:
				DayMonthYearRangeExpression(e);
				break;
			case DAYMONTH:
				DayMonthRangeExpression(e);
				break;
			case MONTHYEAR:
				MonthYearRangeExpression(e);
				break;
			default:
				jj_la1[68] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
	}

	/**
	 * A date range logical expression where date is of form "01APR"
	 */
	final public void DayMonthRangeExpression(StringBuffer e) throws ParseException
	{
		String beg, end;
		int length = 5;
		jj_consume_token(DAYMONTH);
		beg = checkDate(token.image, length);
		jj_consume_token(102);
		jj_consume_token(DAYMONTH);
		end = checkDate(token.image, length);
		e.append(createDayMonthRange(beg, end));
	}

	/**
	 * A date range logical expression where date is of form "APR1976"
	 */
	final public void MonthYearRangeExpression(StringBuffer e) throws ParseException
	{
		String beg, end;
		jj_consume_token(MONTHYEAR);
		beg = token.image;
		jj_consume_token(102);
		jj_consume_token(MONTHYEAR);
		end = token.image;
		e.append(createMonthYearRange(token, beg, end));
	}

	/**
	 * A date range logical expression where date is of form "01APR1976"
	 */
	final public void DayMonthYearRangeExpression(StringBuffer e) throws ParseException
	{
		String beg, end;
		int length = 9;
		jj_consume_token(DAYMONTHYEAR);
		beg = checkDate(token.image, length);
		jj_consume_token(102);
		jj_consume_token(DAYMONTHYEAR);
		end = checkDate(token.image, length);
		e.append(createDayMonthYearRange(token, beg, end));
	}

	/**
	 * A set of non-decision variable expressions delimited by commas - .
	 */
	final public void CommaSeparatedList(StringBuffer e) throws ParseException
	{
		NonDvarExpression(e);
		label_11:
		while(true)
		{
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case 102:
					break;
				default:
					jj_la1[69] = jj_gen;
					break label_11;
			}
			jj_consume_token(102);
			e.append(",");
			NonDvarExpression(e);
		}
	}

	/**
	 * Two non-decision variable expressions delimited by a single comma.
	 */
	final public void OneCommaSeparatedList(StringBuffer e) throws ParseException
	{
		NonDvarExpression(e);
		jj_consume_token(102);
		e.append(",");
		NonDvarExpression(e);
	}

	/**
	 * A set of non-decision variable expressions delimited by commas - at least one comma.
	 */
	final public void MultiCommaSeparatedList(StringBuffer e) throws ParseException
	{
		NonDvarExpression(e);
		label_12:
		while(true)
		{
			jj_consume_token(102);
			e.append(",");
			NonDvarExpression(e);
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case 102:
					break;
				default:
					jj_la1[70] = jj_gen;
					break label_12;
			}
		}
	}

	/**
	 * A list of decision variables and coeficients making up the objective function.
	 */
	final public void ObjectiveListTerm() throws ParseException
	{
		Token d;
		StringBuffer sb = new StringBuffer();
		jj_consume_token(99);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				d = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				d = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				d = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				d = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[71] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		jj_consume_token(102);
		NonDvarExpression(sb);
		jj_consume_token(100);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case 102:
				jj_consume_token(102);
				break;
			default:
				jj_la1[72] = jj_gen;
		}
		if(dvarList.getIndexOf(d.image) < 0)
		{
			if(true)
			{
				throw wreslError(d, "Decision variable '" + d.image
						+ "' has not been defined. No weight should be specified!");
			}
		}
		weights.println("\"" + sb.toString().toUpperCase() + "\",\"" + d.image + "\",\"00\"");
	}

	/**
	 * A symbolic expression that contains no current timestep decision variables.
	 */
	final public void NonDvarExpression(StringBuffer e) throws ParseException
	{
		LPExpression expr = new LPExpression();
		expr.keepLeft();
		LinearExpression(expr);
		if(expr.isConstant())
		{
			e.append(expr.asString());
		}
		else
		{
			{
				if(true)
				{
					throw wreslError(token, "No decision variable terms allowed here");
				}
			}
		}
	}

	/**
	 * A linear combination of decision variables with coefficients and a
	 * constant term.
	 */
	final public void LinearExpression(LPExpression curExpr) throws ParseException
	{
		Token x;
		LPTerm a, b;
		TermExpr(a = new LPTerm());
		curExpr.add(a);
		label_13:
		while(true)
		{
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case ADD:
				case SUBTRACT:
					break;
				default:
					jj_la1[73] = jj_gen;
					break label_13;
			}
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case ADD:
					x = jj_consume_token(ADD);
					break;
				case SUBTRACT:
					x = jj_consume_token(SUBTRACT);
					break;
				default:
					jj_la1[74] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			TermExpr(b = new LPTerm());
			if(x.kind == SUBTRACT)
			{
				b.negate();
			}
			curExpr.add(b);
		}
	}

	/**
	 * An LP term, optionally multiplied or divided by one or more other terms
	 */
	final public void TermExpr(LPTerm ourTerm) throws ParseException
	{
		Token x;
		LPTerm a;
		UnaryExpr(ourTerm);
		label_14:
		while(true)
		{
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case MULTIPLY:
				case DIVIDE:
					break;
				default:
					jj_la1[75] = jj_gen;
					break label_14;
			}
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case MULTIPLY:
					x = jj_consume_token(MULTIPLY);
					break;
				case DIVIDE:
					x = jj_consume_token(DIVIDE);
					break;
				default:
					jj_la1[76] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			UnaryExpr(a = new LPTerm());
			try
			{
				if(x.kind == MULTIPLY)
				{
					ourTerm.multiply(a);
				}
				else
				{
					ourTerm.divide(a);
				}
			}
			catch(ParseException pe)
			{
				{
					if(true)
					{
						throw wreslError(x, pe.getMessage());
					}
				}
			}
		}
	}

	/**
	 * A primary LP term, optionally negated.
	 */
	final public void UnaryExpr(LPTerm ourTerm) throws ParseException
	{
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case SUBTRACT:
				jj_consume_token(SUBTRACT);
				PrimaryExpr(ourTerm);
				ourTerm.negate();
				break;
			case ABS:
			case INT:
			case NINT:
			case REAL:
			case MOD:
			case EXP:
			case LOG:
			case LOG10:
			case SQRT:
			case MAX:
			case MIN:
			case POW:
			case DAYMONTH:
			case MONTHYEAR:
			case DAYMONTHYEAR:
			case CONSTANT:
			case IDENTIFIER:
			case 101:
				PrimaryExpr(ourTerm);
				break;
			default:
				jj_la1[77] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
	}

	/**
	 * A primary term, consisting of at least one of two items, which
	 * are symbolically multiplied together.
	 * These items are (1) an decision variable identifier; and
	 * (2) an expression of non-decision variables.
	 */
	final public void PrimaryExpr(LPTerm ourTerm) throws ParseException
	{
		StringBuffer e;
		Timeseries ts;
		if(jj_2_2(2))
		{
			ParenthesizedIdentifier(ourTerm);
		}
		else if(jj_2_3(2))
		{
			BracketedIdentifier(ourTerm);
		}
		else if(jj_2_4(2))
		{
			IntrinsicFunction(ourTerm);
		}
		else
		{
			switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
			{
				case DAYMONTH:
				case MONTHYEAR:
				case DAYMONTHYEAR:
				case IDENTIFIER:
					switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
					{
						case IDENTIFIER:
							jj_consume_token(IDENTIFIER);
							break;
						case DAYMONTH:
							jj_consume_token(DAYMONTH);
							break;
						case MONTHYEAR:
							jj_consume_token(MONTHYEAR);
							break;
						case DAYMONTHYEAR:
							jj_consume_token(DAYMONTHYEAR);
							break;
						default:
							jj_la1[78] = jj_gen;
							jj_consume_token(-1);
							throw new ParseException();
					}
					int pos;
					// prevent globals from accessing locals
					if(_fileIsLocal == false &&
							includeLevel > 0 &&
							dvarList.getIndexOf(token.image) < 0 &&                                 //not Dvar
							valueDefList.getIndexOf(token.image) < 0 &&     //nor global value svar
							tsDefList.getIndexOf(token.image) < 0 &&                //nor global timeseries svar
							!reservedList.isIn(
									token.image))                                                               //nor Reserved
					{
						if(true)
						{
							throw wreslError(token, "Variable '" + token.image + "' not defined within global scope.");
						}
					}

					if(reservedList.isIn(token.image))
					{
						ourTerm.coef = reservedList.fortranExpr(token.image);
					}
					else if(dvarList.getIndexOf(token.image) >= 0)
					{ // found a decision variable
						ourTerm.setDvar(token.image);
					}
					else if(valueDefList.getIndexOf(token.image) >= 0 ||
							valueDefLocalList.getIndexOf(token.image) >= 0)
					{ // found a value variable
						ourTerm.coef = token.image;
					}
					else if((pos = tsDefList.getIndexOf(token.image)) >= 0)
					{ // found a timeseries variable
						ts = (Timeseries) tsParamList.get(token.image.toUpperCase());
						if(ts.getConvert().equals("'CFS'") && ts.getUnits().equals("'TAF'"))
						{
							ourTerm.coef = "dssin(" + (pos + 1) + ",0)*taf_cfs()";
						}
						else if(ts.getConvert().equals("'TAF'") && ts.getUnits().equals("'CFS'"))
						{
							ourTerm.coef = "dssin(" + (pos + 1) + ",0)*cfs_taf()";
						}
						else
						{
							ourTerm.coef = "dssin(" + (pos + 1) + ",0)";
						}
					}
					else
					{
						{
							if(true)
							{
								throw wreslError(token, "Undeclared variable " + token.image);
							}
						}
					}
					break;
				case CONSTANT:
					jj_consume_token(CONSTANT);
					ourTerm.coef = token.image;      // found a nonnegative numeric constant

					break;
				case 101:
					jj_consume_token(101);
					NonDvarExpression(e = new StringBuffer());
					jj_consume_token(103);
					ourTerm.coef = "(" + e.toString().toUpperCase() + ")";
					break;
				default:
					jj_la1[79] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
		}
	}

	/**
	 * An identifier followed by an expression in parentheses.
	 */
	final public void ParenthesizedIdentifier(LPTerm ourTerm) throws ParseException
	{
		Token x;
		StringBuffer e;
		Timeseries ts;
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				x = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				x = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				x = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				x = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[80] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		jj_consume_token(101);
		CommaSeparatedList(e = new StringBuffer());
		jj_consume_token(103);
		int pos;
		if((pos = dvarList.getIndexOf(x.image)) >= 0)
		{
			ourTerm.coef = "dssdvar(" + (pos + 1) + ",int(" + e + "))";
		}
		else if((pos = tsDefList.getIndexOf(x.image)) >= 0)
		{ // found a timeseries variable
			ts = (Timeseries) tsParamList.get(x.image.toUpperCase());
			if(ts.getConvert().equals("'CFS'") && ts.getUnits().equals("'TAF'"))
			{
				ourTerm.coef = "dssin(" + (pos + 1) + ",int(" + e + "))*taf_cfs(" + e + ")";
			}
			else if(ts.getConvert().equals("'TAF'") && ts.getUnits().equals("'CFS'"))
			{
				ourTerm.coef = "dssin(" + (pos + 1) + ",int(" + e + "))*cfs_taf(" + e + ")";
			}
			else
			{
				ourTerm.coef = "dssin(" + (pos + 1) + ",int(" + e + "))";
			}
		}
		else if(valueDefList.getIndexOf(x.image) >= 0)
		{
			{
				if(true)
				{
					throw wreslError(x, "Previous values of '"
							+ x.image + "' are not available.");
				}
			}
		}
		else if(reservedList.isIn(x.image))
		{           // reserved words
			ourTerm.coef = x.image + "(" + e + ")";
		}
		else if(externalList.containsKey(x.image.toUpperCase()))
		{      // external function call
			ourTerm.coef = x.image + "(" + e + ")";
		}
		else
		{
			{
				if(true)
				{
					throw wreslError(x, "Undeclared Variable '" + x.image + "'");
				}
			}
		}
	}

	/**
	 * An intrinsic function - LF90 intrinsic
	 */
	final public void IntrinsicFunction(LPTerm ourTerm) throws ParseException
	{
		StringBuffer e = new StringBuffer();
		Token x;
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case ABS:
				x = jj_consume_token(ABS);
				jj_consume_token(101);
				NonDvarExpression(e);
				jj_consume_token(103);
				ourTerm.coef = x.image + "(" + e + ")";
				break;
			case INT:
				x = jj_consume_token(INT);
				jj_consume_token(101);
				NonDvarExpression(e);
				jj_consume_token(103);
				ourTerm.coef = x.image + "(" + e + ")";
				break;
			case REAL:
				x = jj_consume_token(REAL);
				jj_consume_token(101);
				NonDvarExpression(e);
				jj_consume_token(103);
				ourTerm.coef = x.image + "(" + e + ")";
				break;
			case EXP:
				x = jj_consume_token(EXP);
				jj_consume_token(101);
				NonDvarExpression(e);
				jj_consume_token(103);
				ourTerm.coef = x.image + "(" + e + ")";
				break;
			case LOG:
				x = jj_consume_token(LOG);
				jj_consume_token(101);
				NonDvarExpression(e);
				jj_consume_token(103);
				ourTerm.coef = x.image + "(" + e + ")";
				break;
			case LOG10:
				x = jj_consume_token(LOG10);
				jj_consume_token(101);
				NonDvarExpression(e);
				jj_consume_token(103);
				ourTerm.coef = x.image + "(" + e + ")";
				break;
			case SQRT:
				x = jj_consume_token(SQRT);
				jj_consume_token(101);
				NonDvarExpression(e);
				jj_consume_token(103);
				ourTerm.coef = x.image + "(" + e + ")";
				break;
			case MAX:
				x = jj_consume_token(MAX);
				jj_consume_token(101);
				MultiCommaSeparatedList(e);
				jj_consume_token(103);
				ourTerm.coef = x.image + "(" + e + ")";
				break;
			case MIN:
				x = jj_consume_token(MIN);
				jj_consume_token(101);
				MultiCommaSeparatedList(e);
				jj_consume_token(103);
				ourTerm.coef = x.image + "(" + e + ")";
				break;
			case POW:
				x = jj_consume_token(POW);
				jj_consume_token(101);
				OneCommaSeparatedList(e);
				jj_consume_token(103);
				ourTerm.coef = x.image + "(" + e + ")";
				break;
			case MOD:
				x = jj_consume_token(MOD);
				jj_consume_token(101);
				OneCommaSeparatedList(e);
				jj_consume_token(103);
				ourTerm.coef = x.image + "(" + e + ")";
				break;
			case NINT:
				x = jj_consume_token(NINT);
				jj_consume_token(101);
				OneCommaSeparatedList(e);
				jj_consume_token(103);
				ourTerm.coef = x.image + "(" + e + ")";
				break;
			default:
				jj_la1[81] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
	}

	/**
	 * An identifier followed by an expression in brackets.
	 */
	final public void BracketedIdentifier(LPTerm ourTerm) throws ParseException
	{
		Token x;
		StringBuffer e;
		Timeseries ts;
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				x = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				x = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				x = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				x = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[82] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		jj_consume_token(99);
		ModelDvarReference(e = new StringBuffer());
		jj_consume_token(100);
		int pos;
		if(_fileIsLocal == false && includeLevel > 0)
		{
			{
				if(true)
				{
					throw wreslError(x, "Variable '" + x.image + "[]' not accessible from global scope");
				}
			}
		}
		else if((pos = dvarList.getIndexOf(x.image)) >= 0)
		{
			ourTerm.coef = "dsscycle(" + (pos + 1) + ",int(" + e + "))";
		}
		else if(valueDefList.getIndexOf(x.image) >= 0)
		{
			{
				if(true)
				{
					throw wreslError(x, "Previous values of '" + x.image + "' are not available.");
				}
			}
		}
		else if(tsDefList.getIndexOf(x.image) >= 0)
		{
			{
				if(true)
				{
					throw wreslError(x, "Timeseries variable '" + x.image + "' should not be followed by [] brackets");
				}
			}
		}
		else
		{
			{
				if(true)
				{
					throw wreslError(x, "Undefined term in brackets: " + x.image);
				}
			}
		}
	}

	/**
	 *
	 */
	final public void ModelDvarReference(StringBuffer e) throws ParseException
	{
		String refmod;
		String reforder;
		Integer refint;
		Token x;
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case IDENTIFIER:
				x = jj_consume_token(IDENTIFIER);
				break;
			case DAYMONTH:
				x = jj_consume_token(DAYMONTH);
				break;
			case MONTHYEAR:
				x = jj_consume_token(MONTHYEAR);
				break;
			case DAYMONTHYEAR:
				x = jj_consume_token(DAYMONTHYEAR);
				break;
			default:
				jj_la1[83] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		refmod = x.image.toUpperCase();
		reforder = (String) sequenceList.get(refmod);
		if(reforder == null)
		{
			{
				if(true)
				{
					throw wreslError(x, "Model '" + x.image + "' not defined!");
				}
			}
		}
		else
		{
			refint = new Integer(reforder);
			int iref = refint.intValue();
			int icur = _currentOrder.intValue();
			if(iref >= icur)
			{
				{
					if(true)
					{
						throw wreslError(x, "Model '" + refmod + "' may not be referenced here! Not yet solved.");
					}
				}
			}
			else
			{
				e.append(iref - icur);
			}
		}
	}

	/**
	 * Definition of an array.
	 */
	final public void ArrayStatement() throws ParseException
	{
		StringBuffer sb = new StringBuffer();
		Token scope, id, size, beg, end, step, counter, expr;
		scope = new Token();
		scope.kind = GLOBAL;
		id = new Token();
		size = new Token();
		counter = new Token();
		beg = new Token();
		end = new Token();
		step = new Token();
		expr = new Token();
		String name;
		int caseNum = 1;
		UniqueList caseList = new UniqueList(4, 4);
		jj_consume_token(ARRAY);
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case 99:
				jj_consume_token(99);
				switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
				{
					case LOCAL:
						scope = jj_consume_token(LOCAL);
						break;
					case GLOBAL:
						scope = jj_consume_token(GLOBAL);
						break;
					default:
						jj_la1[84] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
				jj_consume_token(100);
				break;
			default:
				jj_la1[85] = jj_gen;
		}
		id = jj_consume_token(IDENTIFIER);
		jj_consume_token(99);
		size = jj_consume_token(CONSTANT);
		jj_consume_token(100);
		jj_consume_token(97);
		jj_consume_token(101);
		counter = jj_consume_token(IDENTIFIER);
		jj_consume_token(SINGLE_EQ);
		beg = jj_consume_token(CONSTANT);
		jj_consume_token(102);
		end = jj_consume_token(CONSTANT);
		jj_consume_token(102);
		step = jj_consume_token(CONSTANT);
		jj_consume_token(103);
		name = id.image.toUpperCase();
		if(scope.kind == LOCAL || _fileIsLocal)
		{
			_controlDefines = localDefines;
			if(!valueDefLocalList.newItem(name))
			{
				if(true)
				{
					throw wreslError(id, "Redefining '" + name + "' within Model");
				}
			}
			if(valueDefList.getIdCode(name) != null)
			{
				if(true)
				{
					throw wreslError(id, "Redefining '" + name + "'");
				}
			}
			//CB	  _controlDefines.println(make32( "$"+name));
			_writer.println(_controlDefines, make32("$" + name));  //CB
		}
		else
		{
			_controlDefines = globalDefines;
			if(!valueDefList.newItem(name))
			{
				if(true)
				{
					throw wreslError(id, "Redefining '" + name + "'");
				}
			}
			//CB	  _controlDefines.println(make32("$"+name).append(valueDefList.getIdCode(name)));
			_writer.println(_controlDefines, make32("$" + name).append(valueDefList.getIdCode(name)));
		}
		//CB	_controlDefines.println(size.toString());
		//CB	_controlDefines.println(counter.toString()+"="+beg.toString()+","+end.toString()+","+step.toString());
		//CB	_controlDefines.println(counter.toString());
		_writer.println(_controlDefines, size.toString());
		_writer.println(_controlDefines,
				counter.toString() + "=" + beg.toString() + "," + end.toString() + "," + step.toString());
		_writer.println(_controlDefines, counter.toString());
		switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
		{
			case CASE:
				label_15:
				while(true)
				{
					CaseStatement(caseNum++, caseList, _controlDefines);
					FillArrayStatement(_controlDefines);
					jj_consume_token(98);
					switch((jj_ntk == -1) ? jj_ntk() : jj_ntk)
					{
						case CASE:
							break;
						default:
							jj_la1[86] = jj_gen;
							break label_15;
					}
				}
				break;
			case SUBTRACT:
			case ABS:
			case INT:
			case NINT:
			case REAL:
			case MOD:
			case EXP:
			case LOG:
			case LOG10:
			case SQRT:
			case MAX:
			case MIN:
			case POW:
			case DAYMONTH:
			case MONTHYEAR:
			case DAYMONTHYEAR:
			case CONSTANT:
			case IDENTIFIER:
			case 101:
				soleCondition(_controlDefines);
				FillArrayStatement(_controlDefines);
				break;
			default:
				jj_la1[87] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
		}
		jj_consume_token(98);
		noMoreCases(_controlDefines);
		if(caseNum > 1 && !condIsAlways)
		{
			if(true)
			{
				throw wreslError(id, "Final condition must be 'always' for '" + name + "'");
			}
		}

	}

	/**
	 * Definition of an fillarray.
	 */
	final public void FillArrayStatement(java.io.PrintWriter s) throws ParseException
	{
		StringBuffer sb = new StringBuffer();
		NonDvarExpression(sb);
		s.println(sb);
	}

	final private boolean jj_2_1(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_1();
		jj_save(0, xla);
		return retval;
	}

	final private boolean jj_2_2(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_2();
		jj_save(1, xla);
		return retval;
	}

	final private boolean jj_2_3(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_3();
		jj_save(2, xla);
		return retval;
	}

	final private boolean jj_2_4(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		boolean retval = !jj_3_4();
		jj_save(3, xla);
		return retval;
	}

	final private boolean jj_3R_26()
	{
		if(jj_scan_token(MONTHYEAR))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_39()
	{
		if(jj_scan_token(NINT))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_38()
	{
		if(jj_scan_token(MOD))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_37()
	{
		if(jj_scan_token(POW))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_20()
	{
		if(jj_scan_token(IDENTIFIER))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_36()
	{
		if(jj_scan_token(MIN))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_17()
	{
		Token xsp;
		xsp = jj_scanpos;
		if(jj_3R_20())
		{
			jj_scanpos = xsp;
			if(jj_3R_21())
			{
				jj_scanpos = xsp;
				if(jj_3R_22())
				{
					jj_scanpos = xsp;
					if(jj_3R_23())
					{
						return true;
					}
					if(jj_la == 0 && jj_scanpos == jj_lastpos)
					{
						return false;
					}
				}
				else if(jj_la == 0 && jj_scanpos == jj_lastpos)
				{
					return false;
				}
			}
			else if(jj_la == 0 && jj_scanpos == jj_lastpos)
			{
				return false;
			}
		}
		else if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_35()
	{
		if(jj_scan_token(MAX))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_34()
	{
		if(jj_scan_token(SQRT))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3_4()
	{
		if(jj_3R_19())
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_33()
	{
		if(jj_scan_token(LOG10))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_32()
	{
		if(jj_scan_token(LOG))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_23()
	{
		if(jj_scan_token(DAYMONTHYEAR))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_31()
	{
		if(jj_scan_token(EXP))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_30()
	{
		if(jj_scan_token(REAL))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_29()
	{
		if(jj_scan_token(INT))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_16()
	{
		if(jj_scan_token(RANGE))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_19()
	{
		Token xsp;
		xsp = jj_scanpos;
		if(jj_3R_28())
		{
			jj_scanpos = xsp;
			if(jj_3R_29())
			{
				jj_scanpos = xsp;
				if(jj_3R_30())
				{
					jj_scanpos = xsp;
					if(jj_3R_31())
					{
						jj_scanpos = xsp;
						if(jj_3R_32())
						{
							jj_scanpos = xsp;
							if(jj_3R_33())
							{
								jj_scanpos = xsp;
								if(jj_3R_34())
								{
									jj_scanpos = xsp;
									if(jj_3R_35())
									{
										jj_scanpos = xsp;
										if(jj_3R_36())
										{
											jj_scanpos = xsp;
											if(jj_3R_37())
											{
												jj_scanpos = xsp;
												if(jj_3R_38())
												{
													jj_scanpos = xsp;
													if(jj_3R_39())
													{
														return true;
													}
													if(jj_la == 0 && jj_scanpos == jj_lastpos)
													{
														return false;
													}
												}
												else if(jj_la == 0 && jj_scanpos == jj_lastpos)
												{
													return false;
												}
											}
											else if(jj_la == 0 && jj_scanpos == jj_lastpos)
											{
												return false;
											}
										}
										else if(jj_la == 0 && jj_scanpos == jj_lastpos)
										{
											return false;
										}
									}
									else if(jj_la == 0 && jj_scanpos == jj_lastpos)
									{
										return false;
									}
								}
								else if(jj_la == 0 && jj_scanpos == jj_lastpos)
								{
									return false;
								}
							}
							else if(jj_la == 0 && jj_scanpos == jj_lastpos)
							{
								return false;
							}
						}
						else if(jj_la == 0 && jj_scanpos == jj_lastpos)
						{
							return false;
						}
					}
					else if(jj_la == 0 && jj_scanpos == jj_lastpos)
					{
						return false;
					}
				}
				else if(jj_la == 0 && jj_scanpos == jj_lastpos)
				{
					return false;
				}
			}
			else if(jj_la == 0 && jj_scanpos == jj_lastpos)
			{
				return false;
			}
		}
		else if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_28()
	{
		if(jj_scan_token(ABS))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(101))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_25()
	{
		if(jj_scan_token(DAYMONTH))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3_3()
	{
		if(jj_3R_18())
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3_2()
	{
		if(jj_3R_17())
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_22()
	{
		if(jj_scan_token(MONTHYEAR))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3_1()
	{
		if(jj_3R_16())
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_24()
	{
		if(jj_scan_token(IDENTIFIER))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_18()
	{
		Token xsp;
		xsp = jj_scanpos;
		if(jj_3R_24())
		{
			jj_scanpos = xsp;
			if(jj_3R_25())
			{
				jj_scanpos = xsp;
				if(jj_3R_26())
				{
					jj_scanpos = xsp;
					if(jj_3R_27())
					{
						return true;
					}
					if(jj_la == 0 && jj_scanpos == jj_lastpos)
					{
						return false;
					}
				}
				else if(jj_la == 0 && jj_scanpos == jj_lastpos)
				{
					return false;
				}
			}
			else if(jj_la == 0 && jj_scanpos == jj_lastpos)
			{
				return false;
			}
		}
		else if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		if(jj_scan_token(99))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_27()
	{
		if(jj_scan_token(DAYMONTHYEAR))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	final private boolean jj_3R_21()
	{
		if(jj_scan_token(DAYMONTH))
		{
			return true;
		}
		if(jj_la == 0 && jj_scanpos == jj_lastpos)
		{
			return false;
		}
		return false;
	}

	public void ReInit(java.io.InputStream stream)
	{
		jj_input_stream.ReInit(stream, 1, 1);
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for(int i = 0; i < 88; i++)
		{
			jj_la1[i] = -1;
		}
		for(int i = 0; i < jj_2_rtns.length; i++)
		{
			jj_2_rtns[i] = new JJCalls();
		}
	}

	public void ReInit(java.io.Reader stream)
	{
		jj_input_stream.ReInit(stream, 1, 1);
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for(int i = 0; i < 88; i++)
		{
			jj_la1[i] = -1;
		}
		for(int i = 0; i < jj_2_rtns.length; i++)
		{
			jj_2_rtns[i] = new JJCalls();
		}
	}

	public void ReInit(WreslParserTokenManager tm)
	{
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for(int i = 0; i < 88; i++)
		{
			jj_la1[i] = -1;
		}
		for(int i = 0; i < jj_2_rtns.length; i++)
		{
			jj_2_rtns[i] = new JJCalls();
		}
	}

	final private Token jj_consume_token(int kind) throws ParseException
	{
		Token oldToken;
		if((oldToken = token).next != null)
		{
			token = token.next;
		}
		else
		{
			token = token.next = token_source.getNextToken();
		}
		jj_ntk = -1;
		if(token.kind == kind)
		{
			jj_gen++;
			if(++jj_gc > 100)
			{
				jj_gc = 0;
				for(int i = 0; i < jj_2_rtns.length; i++)
				{
					JJCalls c = jj_2_rtns[i];
					while(c != null)
					{
						if(c.gen < jj_gen)
						{
							c.first = null;
						}
						c = c.next;
					}
				}
			}
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}

	final private boolean jj_scan_token(int kind)
	{
		if(jj_scanpos == jj_lastpos)
		{
			jj_la--;
			if(jj_scanpos.next == null)
			{
				jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
			}
			else
			{
				jj_lastpos = jj_scanpos = jj_scanpos.next;
			}
		}
		else
		{
			jj_scanpos = jj_scanpos.next;
		}
		if(jj_rescan)
		{
			int i = 0;
			Token tok = token;
			while(tok != null && tok != jj_scanpos)
			{
				i++;
				tok = tok.next;
			}
			if(tok != null)
			{
				jj_add_error_token(kind, i);
			}
		}
		return (jj_scanpos.kind != kind);
	}

	final public Token getNextToken()
	{
		if(token.next != null)
		{
			token = token.next;
		}
		else
		{
			token = token.next = token_source.getNextToken();
		}
		jj_ntk = -1;
		jj_gen++;
		return token;
	}

	final public Token getToken(int index)
	{
		Token t = lookingAhead ? jj_scanpos : token;
		for(int i = 0; i < index; i++)
		{
			if(t.next != null)
			{
				t = t.next;
			}
			else
			{
				t = t.next = token_source.getNextToken();
			}
		}
		return t;
	}

	final private int jj_ntk()
	{
		if((jj_nt = token.next) == null)
		{
			return (jj_ntk = (token.next = token_source.getNextToken()).kind);
		}
		else
		{
			return (jj_ntk = jj_nt.kind);
		}
	}

	private void jj_add_error_token(int kind, int pos)
	{
		if(pos >= 100)
		{
			return;
		}
		if(pos == jj_endpos + 1)
		{
			jj_lasttokens[jj_endpos++] = kind;
		}
		else if(jj_endpos != 0)
		{
			jj_expentry = new int[jj_endpos];
			for(int i = 0; i < jj_endpos; i++)
			{
				jj_expentry[i] = jj_lasttokens[i];
			}
			boolean exists = false;
			for(java.util.Enumeration enumer = jj_expentries.elements(); enumer.hasMoreElements(); )
			{
				int[] oldentry = (int[]) (enumer.nextElement());
				if(oldentry.length == jj_expentry.length)
				{
					exists = true;
					for(int i = 0; i < jj_expentry.length; i++)
					{
						if(oldentry[i] != jj_expentry[i])
						{
							exists = false;
							break;
						}
					}
					if(exists)
					{
						break;
					}
				}
			}
			if(!exists)
			{
				jj_expentries.addElement(jj_expentry);
			}
			if(pos != 0)
			{
				jj_lasttokens[(jj_endpos = pos) - 1] = kind;
			}
		}
	}

	final public ParseException generateParseException()
	{
		jj_expentries.removeAllElements();
		boolean[] la1tokens = new boolean[104];
		for(int i = 0; i < 104; i++)
		{
			la1tokens[i] = false;
		}
		if(jj_kind >= 0)
		{
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for(int i = 0; i < 88; i++)
		{
			if(jj_la1[i] == jj_gen)
			{
				for(int j = 0; j < 32; j++)
				{
					if((jj_la1_0[i] & (1 << j)) != 0)
					{
						la1tokens[j] = true;
					}
					if((jj_la1_1[i] & (1 << j)) != 0)
					{
						la1tokens[32 + j] = true;
					}
					if((jj_la1_2[i] & (1 << j)) != 0)
					{
						la1tokens[64 + j] = true;
					}
					if((jj_la1_3[i] & (1 << j)) != 0)
					{
						la1tokens[96 + j] = true;
					}
				}
			}
		}
		for(int i = 0; i < 104; i++)
		{
			if(la1tokens[i])
			{
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.addElement(jj_expentry);
			}
		}
		jj_endpos = 0;
		jj_rescan_token();
		jj_add_error_token(0, 0);
		int[][] exptokseq = new int[jj_expentries.size()][];
		for(int i = 0; i < jj_expentries.size(); i++)
		{
			exptokseq[i] = (int[]) jj_expentries.elementAt(i);
		}
		return new ParseException(token, exptokseq, tokenImage);
	}

	final public void enable_tracing()
	{
	}

	final public void disable_tracing()
	{
	}

	final private void jj_rescan_token()
	{
		jj_rescan = true;
		for(int i = 0; i < 4; i++)
		{
			JJCalls p = jj_2_rtns[i];
			do
			{
				if(p.gen > jj_gen)
				{
					jj_la = p.arg;
					jj_lastpos = jj_scanpos = p.first;
					switch(i)
					{
						case 0:
							jj_3_1();
							break;
						case 1:
							jj_3_2();
							break;
						case 2:
							jj_3_3();
							break;
						case 3:
							jj_3_4();
							break;
					}
				}
				p = p.next;
			} while(p != null);
		}
		jj_rescan = false;
	}

	final private void jj_save(int index, int xla)
	{
		JJCalls p = jj_2_rtns[index];
		while(p.gen > jj_gen)
		{
			if(p.next == null)
			{
				p = p.next = new JJCalls();
				break;
			}
			p = p.next;
		}
		p.gen = jj_gen + xla - jj_la;
		p.first = token;
		p.arg = xla;
	}

	static final class JJCalls
	{
		int gen;
		Token first;
		int arg;
		JJCalls next;
	}

}
